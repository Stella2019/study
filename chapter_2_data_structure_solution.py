# -*- coding: utf-8 -*-
"""chapter_2_data_structure_solution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fAdLK7ACuCsWOZ_YBvDVt45jQTx52bWo

<h1>Table of Contents<span class="tocSkip"></span></h1>
<div class="toc"><ul class="toc-item"><li><span><a href="#Overview" data-toc-modified-id="Overview-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Overview</a></span></li><li><span><a href="#Learning-Objectives" data-toc-modified-id="Learning-Objectives-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Learning Objectives</a></span></li><li><span><a href="#Array" data-toc-modified-id="Array-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Array</a></span><ul class="toc-item"><li><span><a href="#Definition" data-toc-modified-id="Definition-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>Definition</a></span></li><li><span><a href="#Array-in-Python" data-toc-modified-id="Array-in-Python-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>Array in Python</a></span></li><li><span><a href="#Example-($\star$)" data-toc-modified-id="Example-($\star$)-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>Example ($\star$)</a></span><ul class="toc-item"><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.3.1"><span class="toc-item-num">3.3.1&nbsp;&nbsp;</span>Discussion</a></span></li></ul></li><li><span><a href="#Exercise-($\star$)" data-toc-modified-id="Exercise-($\star$)-3.4"><span class="toc-item-num">3.4&nbsp;&nbsp;</span>Exercise ($\star$)</a></span><ul class="toc-item"><li><span><a href="#Discussion:" data-toc-modified-id="Discussion:-3.4.1"><span class="toc-item-num">3.4.1&nbsp;&nbsp;</span>Discussion:</a></span></li></ul></li><li><span><a href="#Example-($\star\star$)" data-toc-modified-id="Example-($\star\star$)-3.5"><span class="toc-item-num">3.5&nbsp;&nbsp;</span>Example ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-3.6"><span class="toc-item-num">3.6&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.7"><span class="toc-item-num">3.7&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Example-($\star\star\star$)" data-toc-modified-id="Example-($\star\star\star$)-3.8"><span class="toc-item-num">3.8&nbsp;&nbsp;</span>Example ($\star\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.9"><span class="toc-item-num">3.9&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-3.10"><span class="toc-item-num">3.10&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.11"><span class="toc-item-num">3.11&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-3.12"><span class="toc-item-num">3.12&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-3.13"><span class="toc-item-num">3.13&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-3.14"><span class="toc-item-num">3.14&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-3.15"><span class="toc-item-num">3.15&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li></ul></li><li><span><a href="#Stack" data-toc-modified-id="Stack-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>Stack</a></span><ul class="toc-item"><li><span><a href="#Definition" data-toc-modified-id="Definition-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>Definition</a></span></li><li><span><a href="#Example-($\star\star$)" data-toc-modified-id="Example-($\star\star$)-4.2"><span class="toc-item-num">4.2&nbsp;&nbsp;</span>Example ($\star\star$)</a></span></li><li><span><a href="#Example-($\star\star$)" data-toc-modified-id="Example-($\star\star$)-4.3"><span class="toc-item-num">4.3&nbsp;&nbsp;</span>Example ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.4"><span class="toc-item-num">4.4&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.5"><span class="toc-item-num">4.5&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.6"><span class="toc-item-num">4.6&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-4.7"><span class="toc-item-num">4.7&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.8"><span class="toc-item-num">4.8&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Example-($\star\star$)" data-toc-modified-id="Example-($\star\star$)-4.9"><span class="toc-item-num">4.9&nbsp;&nbsp;</span>Example ($\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-4.10"><span class="toc-item-num">4.10&nbsp;&nbsp;</span>Discussion</a></span></li></ul></li><li><span><a href="#Queue" data-toc-modified-id="Queue-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>Queue</a></span><ul class="toc-item"><li><span><a href="#Definition" data-toc-modified-id="Definition-5.1"><span class="toc-item-num">5.1&nbsp;&nbsp;</span>Definition</a></span></li></ul></li><li><span><a href="#Appendix" data-toc-modified-id="Appendix-6"><span class="toc-item-num">6&nbsp;&nbsp;</span>Appendix</a></span><ul class="toc-item"><li><span><a href="#Hints-for-exercise-3.4:" data-toc-modified-id="Hints-for-exercise-3.4:-6.1"><span class="toc-item-num">6.1&nbsp;&nbsp;</span>Hints for <a href="#3.4">exercise 3.4</a>:</a></span></li><li><span><a href="#Hints-for-exercise-3.6:" data-toc-modified-id="Hints-for-exercise-3.6:-6.2"><span class="toc-item-num">6.2&nbsp;&nbsp;</span>Hints for <a href="#3.6">exercise 3.6</a>:</a></span></li><li><span><a href="#Hints-for-exercise-3.10:" data-toc-modified-id="Hints-for-exercise-3.10:-6.3"><span class="toc-item-num">6.3&nbsp;&nbsp;</span>Hints for <a href="#3.10">exercise 3.10</a>:</a></span></li><li><span><a href="#Hints-for-exercise-3.12:" data-toc-modified-id="Hints-for-exercise-3.12:-6.4"><span class="toc-item-num">6.4&nbsp;&nbsp;</span>Hints for <a href="#3.12">exercise 3.12</a>:</a></span></li><li><span><a href="#Hints-for-exercise-3.13:" data-toc-modified-id="Hints-for-exercise-3.13:-6.5"><span class="toc-item-num">6.5&nbsp;&nbsp;</span>Hints for <a href="#3.13">exercise 3.13</a>:</a></span></li><li><span><a href="#Hints-for-exercise-3.14:" data-toc-modified-id="Hints-for-exercise-3.14:-6.6"><span class="toc-item-num">6.6&nbsp;&nbsp;</span>Hints for <a href="#3.14">exercise 3.14</a>:</a></span></li><li><span><a href="#Hints-for-exercise-3.15:" data-toc-modified-id="Hints-for-exercise-3.15:-6.7"><span class="toc-item-num">6.7&nbsp;&nbsp;</span>Hints for <a href="#3.15">exercise 3.15</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.4:" data-toc-modified-id="Hints-for-exercise-4.4:-6.8"><span class="toc-item-num">6.8&nbsp;&nbsp;</span>Hints for <a href="#4.4">exercise 4.4</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.5:" data-toc-modified-id="Hints-for-exercise-4.5:-6.9"><span class="toc-item-num">6.9&nbsp;&nbsp;</span>Hints for <a href="#4.5">exercise 4.5</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.6:" data-toc-modified-id="Hints-for-exercise-4.6:-6.10"><span class="toc-item-num">6.10&nbsp;&nbsp;</span>Hints for <a href="#4.6">exercise 4.6</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.8:" data-toc-modified-id="Hints-for-exercise-4.8:-6.11"><span class="toc-item-num">6.11&nbsp;&nbsp;</span>Hints for <a href="#4.8">exercise 4.8</a>:</a></span></li></ul></li></ul></div>

<b>

<p>
<center>
<font size="5">
Lecture Note for Computer Science Foundations (DATS 6450)
</font>
</center>
</p>

<p>
<center>
<font size="4">
Chapter 2: Array, Stack, and Queue (Solution)
</font>
</center>
</p>

<p>
<center>
<font size="3">
Data Science, Columbian College of Arts & Sciences, George Washington University
</font>
</center>
</p>

<p>
<center>
<font size="3">
Author: Yuxiao Huang
</font>
</center>
</p>

</b>

# Overview
- We will discuss three kinds of basic data structures in this chapter, including:
    - array
    - stack
    - queue
- The discussion of each kind of data structure can be divided into two parts:
    - theory, where we will describe the idea of the data structure
    - coding
        - where (most of the time) we will start with some examples and then work on some exercises
        - particularly, the examples and exercises are organized in such a way that, an exercise (most of the time) is a follow-up on some example prior to it
        - **you should analyze the (time and space) complexity of each example and exercise**
- We will use stars to represent the difficulty of the exercises:
    - $\star$ means very easy
    - $\star\star$ means easy
    - $\star\star\star$ means medium
    - $\star\star\star\star$ means difficult
    - $\star\star\star\star\star$ means very difficult

# Learning Objectives
Students should know:
- how the three kinds of data structures work
- how to apply these data structures to design optimal solutions (ones with the lowest complexity)

# Array
We will start with array, which is perhaps the most widely used data structure in algorithm design. In this course most of the solutions will be implemented using array.

## Definition
In simple words, an *array* is a data structure that stores the same type of items at contiguous memory locations. The idea of array is that, if we know the memory address of the first element in the array, then we can access any element in constant time (i.e., $O(1)$). Accessing an item in the array from its index is also called *array indexing*. 

Array indexing takes constant time because of two reasons. First, we can calculate the memory address of the $i$th element using 

\begin{equation}
a + i \times s.
\end{equation}

Here $a$ is the address of the first element in the array, and $s$ is the space each element takes (this is why we require the elements in an array must have the same type, so that $s$ will be the same for every element). Second, we can retrieve the element from the address in the equation above. Both calculating the address and retrieving the element take constant time. This is the key reason why array is one of the most important data structures in algorithm design.

In practice, the two steps are combined in one. Moreover, we do not have to know the $a$ and $s$ in the equation above (they will be taken care of by the complier). All we need to know is the index of the element we want to access. For example, for an array named arr, arr[i] will give us the $i$th element in the array (more on this later).

## Array in Python 
While array is a primitive data structure in most of the programming languages (e.g., C, C++, and JAVA), it is not the case in Python. Instead, Python has a primitive data structure, named *list*, which can be used as array since *list indexing* (accessing an item in the list from its index) also takes constant time. What is more, list also supports operations that array (in other programming languages) does not allow (e.g., adding or removing an element, and list comprehension, more on this later). Hereafter unless otherwise specified we will use list and array interchangeably. Below are some very simple examples of using list.
"""

# Initialize a list using different numbers
arr = [1, 2, 3, 4]
arr

# Initialize a list using the same number, say 0
arr = [0] * 10
arr

# List indexing
arr = [1, 2, 3, 4]
for i in range(len(arr)):
    print(arr[i])

"""It is worth noting that, while array is not a primitive data structure in Python, the language does have build-in packages that implement array. Among these packages, perhaps the most widely used is *numpy*, which implements *numpy Array* (or *ndarray*). Numpy array provides vectorized arithmetic operations (e.g., matrix multiplication) which are highly efficient. This is the reason why, as far as we know, most of the machine learning models in [scikit-learn](https://scikit-learn.org/stable/) are implemented using numpy array.

Despite of the appealing performance of numpy, it will not be used in this course. One reason is that, some of the algorithms (e.g., binary search) that you will learn and practice have already been implemented in numpy. This is also why, according to our knowledge, numpy cannot be used in the "Whiteboard Coding" interviews.

<a id='3.3'></a>

## Example ($\star$)
- Problem: 
    - find the largest element in the array
    - you may assume the array is not empty
    - the solution has the complexity below
    - this example will be followed by
        - [exercise 3.4](#3.4)
- Complexity: 
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - looping through an array
    - avoiding unnecessary computation
- Logic: see the comments below
"""

# Implementation
def fun_33(arr):
    """
    Find the largest element in the array
    You may assume the array is not empty
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The largest element in arr: an integer
    """
    
    # Since we can assume the array is not empty (as suggested in the docstring), 
    # assign the first element to max_
    max_ = arr[0]
    
    # Loop over each remaining element in the array
    for i in range(1, len(arr)):
        if max_ < arr[i]:
            # Update max_
            max_ = arr[i]
            
    return max_

# Test
arr_1 = [2]
arr_2 = [2, 3]

print(fun_33(arr_1))
print(fun_33(arr_2))

"""### Discussion
- what happens when replacing $<$ with $<=$ in the solution?
- can you design a different solution?

<a id='3.4'></a>

## Exercise ($\star$)
- Problem:
    - follow up on [example 3.3](#3.3)
    - you cannot assume the array is not empty
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - handling corner cases of the input
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.4)
"""

# Implementation
def fun_34(arr):
    """
    Find the largest element in the array
    You cannot assume the array is not empty
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The largest element in arr, if nonempty array
    None, otherwise
    """
    
    # Implement me
    # Initialize max_ with None (which should be returned if the array is empty)
    max_ = None
    
    # Loop over each element in the array
    for x in arr:
        if max_ is None or max_ < x:
            # Update max_
            max_ = x
            
    return max_

# Test
arr_1 = []
arr_2 = [2]
arr_3 = [2, 3]

print(fun_34(arr_1))
print(fun_34(arr_2))
print(fun_34(arr_3))

"""### Discussion:
- identifying and handling corner cases is an important skill in algorithm design (and more broadly, software engineering)
- you are strongly recommended to
    - come up with as many corner cases as possible, and consider these cases when designing the algorithm
    - include the corner cases when testing the algorithm

<a id='3.5'></a>

## Example ($\star\star$)
- Problem:
    - find the largest sum across all the contiguous (non-empty) subarrays of the input array
    - you may assume the input array is not empty
    - find the brute-force solution with the complexity below
    - this example will be followed by
        - [exercise 3.6](#3.6)
        - [exercise 3.12](#3.12)
- Complexity: 
    - $O(n^3)$ time
    - $O(1)$ space
- Skills:
    - solving a non-trivial problem by starting with a brute-force solution
- Logic:
    - we first loop over each possible continuous (non-empty) subarray and calculate its sum
    - we then return the largest sum across all the subarrays
"""

# Implementation
def fun_35(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The largest sum : an interger
    """
    
    # The largest sum
    max_sum = None
    
    # For each possible start of the subarray
    for i in range(len(arr)):
        # For each possible end of the subarray
        for j in range(i, len(arr)):
            # The sum of the subarray (starting with i and ending with j)
            sum_ = 0
            for k in range(i, j + 1):
                sum_ += arr[k]
            
            if max_sum is None or max_sum < sum_:
                # Update max_sum
                max_sum = sum_
            
    return max_sum

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_35(arr_1))
print(fun_35(arr_2))
print(fun_35(arr_3))

"""<a id='3.6'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [example 3.5](#3.5)
    - find an improved solution with the complexity below
    - this exercise will be followed by
        - [example 3.8](#3.8)
        - [exercise 3.13](#3.13)
- Complexity: 
    - $O(n^2)$ time
    - $O(1)$ space
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.6)
"""

# Implementation
def fun_36(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The largest sum : an interger
    """
    
    # Implement me
    # The largest sum
    max_sum = None
    
    # For each possible start of the subarray
    for i in range(len(arr)):
        # The sum of the subarray (starting with i)
        sum_ = 0
        # For each possible end of the subarray
        for j in range(i, len(arr)):
            # The sum of the subarray (ending with j)
            sum_ += arr[j]
            
            if max_sum is None or max_sum < sum_:
                # Update max_sum
                max_sum = sum_
            
    return max_sum

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_36(arr_1))
print(fun_36(arr_2))
print(fun_36(arr_3))

"""## Discussion
In theory, the improved solution (with $O(n^2)$ time complexity) is one order of magnitude faster than the brute-force solution (with $O(n^3)$). This is also demonstrated empirically by comparing their run time across a series of input, as shown in fig. 1.
"""

# Commented out IPython magic to ensure Python compatibility.
import time
# %matplotlib inline
import matplotlib.pyplot as plt

def plot(n, funs):
    """
    Plot the run time of the functions (with respect to the input size).
    
    Parameters
    ----------
    n : a number
    funs : a list of functions
    """
    
    x = list(range(n + 1))
    ys = [[] for _ in range(len(funs))]

    for i in x:
        for j in range(len(funs)):
            start = time.time()
            funs[j](list(range(i + 1)))
            end = time.time()
            ys[j].append(end - start)
    
    for j in range(len(funs)):
        plt.plot(x, ys[j], label=funs[j].__name__)
    plt.xlabel('$n$', fontsize=20)
    plt.ylabel('Run time', fontsize=20)
    plt.xticks([min(x), max(x)], fontsize=20)
    plt.yticks([min([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))]), max([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))])], fontsize=20)
    plt.legend(fontsize=20)
    plt.tight_layout()
    plt.show()

plot(200, [fun_35, fun_36])
print("Figure 1. The run time of fun_35 and fun_36.")

"""<a id='3.8'></a>

## Example ($\star\star\star$)
- Problem:
    - follow up on [exercise 3.6](#3.6)
    - find an improved solution with the complexity below
    - this example will be followed by
        - [exercise 3.14](#3.14)
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - further improving the solution (by lowering the time complexity)
- Logic:
    - the contiguous subarray has $n$ possible ending points, $0, 1, \ldots, n - 1$
    - we can use an array, sum_arr, to record the sum of these arrays, where sum_arr[i] is the sum of the subarray ending at index $i$
    - specifically, sum_arr[i] can be calculated this way:
        - if sum_arr[i - 1] > 0, then sum_arr[i] = sum_arr[i - 1] + arr[i], meaning the subarray extends from $i - 1$ to $i$
        - otherwise, sum_arr[i] = arr[i], meaning the subarray starts at index $i$
    - last, we return the largest sum in sum_arr
"""

# Implementation
def fun_38(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The largest sum : an interger
    """
    
    sum_arr = [0] * len(arr)
    # Corner case
    sum_arr[0] = arr[0]
    
    for i in range(1, len(arr)):
        if sum_arr[i - 1] > 0:
            sum_arr[i] = sum_arr[i - 1] + arr[i]
        else:
            sum_arr[i] = arr[i]
      
    return max(sum_arr)

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_38(arr_1))
print(fun_38(arr_2))
print(fun_38(arr_3))

"""## Discussion
Compared to fun_36 (the solution for [exercise 3.6](#3.6)), in fun_38 we further improved the time complexity by one order of magnitude (from $O(n^2)$ to $O(n)$). This is also demonstrated empirically by comparing their run time, as shown in fig. 2.
"""

plot(300, [fun_36, fun_38])
print("Figure 2. The run time of fun_36 and fun_38")

"""It is worth noting that, compared to fun_36 while the time complexity was decreased in fun_38, the space complexity, on the other hand, was increased, from $O(1)$ to $O(n)$ (can you explain why?). This is usually acceptable since, as we mentioned in chapter 1, most of the time the speed is the property of an algorithm we care about the most.

However, it does not mean we should stop here, because we can actually lower the space to $O(1)$ while keeping the time as $O(n)$. The corresponding solution, as a matter of fact, is the optimal solution. Can you explain why?

<a id='3.10'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [example 3.8](#3.8)
    - find the optimal solution with the complexity below
    - this exercise will be followed by
        - [exercise 3.15](#3.15)
- Complexity: 
    - $O(n)$ time
    - $O(1)$ space
- Skills:
    - further improving the solution (by lowering the space complexity) to reach the optimal solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.10)
"""

# Implementation
def fun_310(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The largest sum : an interger
    """
    
    # Implement me
    global_max, local_max = arr[0], arr[0]
        
    for i in range(1, len(arr)):
        if local_max > 0:
            local_max += arr[i]
        else:
            local_max = arr[i]
        if global_max < local_max:
            global_max = local_max
            
    return global_max

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_310(arr_1))
print(fun_310(arr_2))
print(fun_310(arr_3))

"""## Discussion
**Q**: Comparing the solution for [example 3.8](#3.8) (fun_38) and that for [exercise 3.10](#3.10) (fun_310), which one is faster and why?

**A**: While both of them have linear time complexity (meaning they have the same asymptotic order of growth), fun_310 is faster than fun_38, as shown in fig. 3. While the difference is trivial, it is actually quite important to know why this is the case, since this will show you how to distinguish algorithms (in terms of their speed) with the same asymptotic order of growth (or big $O$).

The reason why fun_38 is slower than fun_310 is that, the first needs to pass the array three times (can you explain why?), taking $3 n$ steps, whereas the second only needs to pass the array once, taking $n$ steps. This theoretically explains the difference in fig. 3.
"""

plot(10 ** 4, [fun_38, fun_310])
print("Figure 3. The run time of fun_38 and fun_310.")

"""<a id='3.12'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [example 3.5](#3.5)
    - unlike in the example 
        - where the function only returns the largest sum, here the function also returns the index of the first and last element in the subarray (that has the largest sum)
        - where we only assume that the input array is not empty, here we also assume that there is exactly one subarray (that has the largest sum)
    - find the solution with the complexity below
- Complexity: 
    - $O(n^3)$ time
    - $O(1)$ space
- Skills:
    - tweaking an existing solution to fulfill the new requirements
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.12)
"""

# Implementation
def fun_312(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    You may also assume there is exactly one subarray (that has the largest sum)
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    [the largest sum, 
    the index of the first element in the subarray, 
    the index of the last element in the subarray]
    : a list  
    """
    
    # Implement me
    # The largest sum, and the index of the first and last element
    max_sum, first_idx, last_idx = None, 0, 0
    
    # For each possible start of the subarray
    for i in range(len(arr)):
        # For each possible end of the subarray
        for j in range(i, len(arr)):
            # The sum of the subarray (starting with i and ending with j)
            sum_ = 0
            for k in range(i, j + 1):
                sum_ += arr[k]
            
            if max_sum is None or max_sum < sum_:
                # Update max_sum, first_idx, and last_idx
                max_sum, first_idx, last_idx = sum_, i, j
            
    return [max_sum, first_idx, last_idx]

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_312(arr_1))
print(fun_312(arr_2))
print(fun_312(arr_3))

"""<a id='3.13'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 3.6](#3.6)
    - unlike in the exercise 
        - where the function only returns the largest sum, here the function also returns the index of the first and last element in the subarray (that has the largest sum)
        - where we only assume that the input array is not empty, here we also assume that there is exactly one subarray (that has the largest sum)
    - find the solution with the complexity below
- Complexity: 
    - $O(n^2)$ time
    - $O(1)$ space
- Skills:
    - tweaking an existing solution to fulfill the new requirements
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.13)
"""

# Implementation
def fun_313(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    You may also assume there is exactly one subarray (that has the largest sum)
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    [the largest sum, 
    the index of the first element in the subarray, 
    the index of the last element in the subarray]
    : a list  
    """
    
    # Implement me
    # The largest sum, and the index of the first and last element
    max_sum, first_idx, last_idx = None, 0, 0
    
    # For each possible start of the subarray
    for i in range(len(arr)):
        # The sum of the subarray (starting with i)
        sum_ = 0
        # For each possible end of the subarray
        for j in range(i, len(arr)):
            # The sum of the subarray (ending with j)
            sum_ += arr[j]
            
            if max_sum is None or max_sum < sum_:
                # Update max_sum, first_idx, and last_idx
                max_sum, first_idx, last_idx = sum_, i, j
            
    return [max_sum, first_idx, last_idx]

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_313(arr_1))
print(fun_313(arr_2))
print(fun_313(arr_3))

"""<a id='3.14'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [example 3.8](#3.8)
    - unlike in the example 
        - where the function only returns the largest sum, here the function also returns the index of the first and last element in the subarray (that has the largest sum)
        - where we only assume that the input array is not empty, here we also assume that there is exactly one subarray (that has the largest sum)
    - find the solution with the complexity below
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - tweaking an existing solution to fulfill the new requirements
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.14)
"""

# Implementation
def fun_314(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    You may also assume there is exactly one subarray (that has the largest sum)
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    [the largest sum, 
    the index of the first element in the subarray, 
    the index of the last element in the subarray]
    : a list  
    """
    
    # Implement me
    sum_arr = [0] * len(arr)
    # Corner case
    sum_arr[0] = arr[0]
    
    for i in range(1, len(arr)):
        if sum_arr[i - 1] > 0:
            sum_arr[i] = sum_arr[i - 1] + arr[i]
        else:
            sum_arr[i] = arr[i]

    # The largest sum and the index of the last element
    max_sum, last_idx = None, 0
    
    for i in range(len(arr)):
        if max_sum is None or max_sum < sum_arr[i]:
            # Update max_sum and last_idx
            max_sum, last_idx = sum_arr[i], i
    
    sum_ = max_sum
    # The index of the first element
    first_idx = last_idx + 1
    
    while (sum_ != 0):
        first_idx -= 1
        sum_ -= arr[first_idx]
        
    return [max_sum, first_idx, last_idx]

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_314(arr_1))
print(fun_314(arr_2))
print(fun_314(arr_3))

"""<a id='3.15'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 3.10](#3.10)
    - unlike in the exercise 
        - where the function only returns the largest sum, here the function also returns the index of the first and last element in the subarray (that has the largest sum)
        - where we only assume that the input array is not empty, here we also assume that there is exactly one subarray (that has the largest sum)
    - find the solution with the complexity below
- Complexity: 
    - $O(n)$ time
    - $O(1)$ space
- Skills:
    - tweaking an existing solution to fulfill the new requirements
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_3.15)
"""

# Implementation
def fun_315(arr):
    """
    Find the largest sum across all the contiguous (non-empty) subarrays of the input array
    You may assume the input array is not empty
    You may also assume there is exactly one subarray (that has the largest sum)
    
    Parameters
    ----------
    arr : an array
    
    Returns
    ----------
    [the largest sum, 
    the index of the first element in the subarray, 
    the index of the last element in the subarray]
    : a list
    
    """
    
    # Implement me
    global_max, local_max = arr[0], arr[0]
    first_idx, last_idx, first_idx_temp = 0, 0, 0
        
    for i in range(1, len(arr)):
        if local_max > 0:
            local_max += arr[i]
        else:
            local_max, first_idx_temp = arr[i], i
        if global_max < local_max:
            global_max, first_idx, last_idx = local_max, first_idx_temp, i

    return [global_max, first_idx, last_idx]

# Test
arr_1 = [2]
arr_2 = [-2, 3]
arr_3 = [-2, 3, -2, 4, -1, -2]

print(fun_315(arr_1))
print(fun_315(arr_2))
print(fun_315(arr_3))

"""# Stack
While array is probably the most important data structure, it is by no means the only one that we can use for algorithm design. Other data structures, such as linked list, stack, queue, tree, graph and heap are also widely used. Since linked list performs quite similar to Python list (the built-in data structure we have been using for array), we will skip it and refer the interested reader to chapter 10 of [*Introduction to Algorithms (Third Edition)*](https://mitpress.mit.edu/books/introduction-algorithms-third-edition) for details. For the remaining data structures, we will discuss the basic ones including stack and queue in this chapter, and leave the advanced ones to later chapters.

## Definition
In simple words, *stack* is a structure where data are stored in a LIFO (last in first out) fashion. It turns out that, the way how stack stores data is exactly the same as the way how stack stores say, plates. The plate on the top is the one that goes in the last but comes out the first (i.e., LIFO). This example also shows two major operations of stack, pushing (the plate into the stack) and popping (the plate off the stack). The stack data structure and its operations are supported by, again, Python list. Below are two very simple examples of using list as stack.
"""

# Initialize a stack
stack = [1]

# Push 2 into the stack
stack.append(2)
print(stack)

# Pop the top off the stack
print(stack.pop())
print(stack)

"""Stack has been used for problems such as recursion, function call, parenthesis checking and expression evaluation. Here is an example illustrating the first two applications. The last two will be discussed later.

<a id='4.2'></a>

## Example ($\star\star$)

In chapter 1, we introduced the recursive solution for the [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number). Particularly, we used the recursion tree to analyze the time complexity of the solution. Fig. 4 shows the recursion tree when the input is 5 (where $f(i)$ denotes the $i$th number in the series), that is, we want to know the fifth number in the series.

<img src="../figure/figure_4.pdf" width="500" height="500">

Figure 4. The recursion tree when $n = 5$.

Here we will show how we can calculate $f(5)$ using two stacks. This can be done in 30 steps, where the two stacks in each step are shown in the corresponding panel in fig. 5. Specifically, the stack on the top of each panel is used for storing $f(0), f(1), \ldots, f(5)$, and the stack on the bottom is used for storing their values. We will use stack $i$.1 to denote the stack on the top in panel $(i)$ and use stack $i$.2 to denote the stack on the bottom.

Let us look at the first five steps for calculating $f(5)$:
- $f(5)$ is unknown, so we push it into stack 1.1 (the top stack in panel (1))
- calculating the top of stack 1.1, $f(5)$, requires its left child, $f(4)$, so we push it into stack 2.1
- calculating the top of stack 2.1, $f(4)$, requires its left child, $f(3)$, so we push it into stack 3.1
- calculating the top of stack 3.1, $f(3)$, requires its left child, $f(2)$, so we push it into stack 4.1
- calculating the top of stack 4.1, $f(2)$, requires its left child, $f(1)$, so we push it into stack 5.1

<img src="../figure/figure_5.pdf" width="1000" height="1000">

Figure 5. The two stacks used across the 30 steps for calculating $f(5)$.

It seems that nothing happened to the bottom stack in any of the first five panels. This is because, as we mentioned previously, this stack is used for storing the value for $f(0), f(1), \ldots, f(5)$. We do not know the value for any of them, except for $f(0)$ and $f(1)$ (the base in the recursive solution of example 8.1 in chapter 1). This is the reason why the bottom stack did not change at all in the first five steps. 

However, since the top of stack 5.1, $f(1)$, is 1, we pop $f(1)$ off stack 6.1 and push 1 into stack 6.2. It is worth noting that $f(1)$ is the left child of $f(2)$ (in the left most path of the recursion tree) and its value is now on the top of stack 6.2.

Next we push the right child of $f(2)$, $f(0)$, into stack 7.1. Since $f(0)$ is 0, we pop it off stack 8.1 and push its value, 0, into stack 8.2. Now both the left-child and right-child of $f(2)$ have been calculated. We can pop $f(2)$ off stack 9.1. We can also pop the value of its two children off stack 9.2 and push their sum, which is the value of $f(2)$, into stack 10.2.

The stacks for calculating the remaining nodes in the recursion tree are shown in panels 11 to 30. Specifically, panels 11 to 19 show the stacks used for calculating the left subtree, whereas panels 20 to 30 show the stacks used for calculating the right subtree and the root, $f(5)$ (can you explain what happens under the hood?). The value of the root can be seen in stack 30.2.

Last but not least, fig. 5 also experimentally demonstrated the space complexity ($O(n)$) of the recursive solution (example 8.1, chapter 1) we theoretically explained. As shown in the figure, the sum of the space used by the two stacks in each step is never larger than 6, which is the maximum number of levels in the recursion tree.

<a id='4.3'></a>

## Example ($\star\star$)
- Problem:
    - check whether the parentheses in the input string are valid
    - the parentheses are valid if they are always in pairs and in correct order 
    - you may assume the string only includes '(' and ')'
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.4](#4.4)
        - [exercise 4.5](#4.5)
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - using stack
- Logic: see the comments below
"""

def fun_43(s):
    """
    Check whether the parentheses in the input string are valid
    The parentheses are valid if they are always in pairs and in correct order 
    You may assume the string only includes '(' and ')'
    
    Parameters
    ----------
    s : a string
    
    Returns
    ----------
    True or False : boolean
    """

    stack = []

    for c in s:
        if c == ')':
            # If the parentheses are not in pairs or in correct order
            if (len(stack) == 0) or ('(' != stack.pop()):
                return False
        else:
            # Push '('
            stack.append(c)

    return True if len(stack) == 0 else False

# Test
s_1 = "()"
s_2 = ")("
s_3 = "()()"
s_4 = "(())"

print(fun_43(s_1))
print(fun_43(s_2))
print(fun_43(s_3))
print(fun_43(s_4))

"""<a id='4.4'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [example 4.3](#4.3)
    - find an improved solution with the complexity below
- Complexity: 
    - $O(n)$ time
    - $O(1)$ space
- Skills:
    - improving the solution (by lowering the space complexity) to reach the optimal solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.4)
"""

def fun_44(s):
    """
    Check whether the parentheses in the input string are valid
    The parentheses are valid if they are always in pairs and in correct order 
    You may assume the string only includes '(' and ')'
    
    Parameters
    ----------
    s : a string
    
    Returns
    ----------
    True or False : boolean
    """

    # Implement me
    count = 0

    for c in s:
        if c == ')':
            count -= 1            
        else:
            count += 1
        # If the parentheses are not in correct order
        if count < 0:
            return False
    
    # If the parentheses are in pairs, return True; Otherwise, return False
    return True if count == 0 else False

# Test
s_1 = "()"
s_2 = ")("
s_3 = "()()"
s_4 = "(())"

print(fun_44(s_1))
print(fun_44(s_2))
print(fun_44(s_3))
print(fun_44(s_4))

"""<a id='4.5'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [example 4.3](#4.3)
    - you may assume the string includes not only '(' and ')', but also '[' and ']' and '{' and '}'   
    - find a solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.6](#4.6)
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - tweaking an existing solution to fulfill the new requirements
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.5)
"""

def fun_45(s):
    """
    Check whether the parentheses in the input string are valid
    The parentheses are valid if they are always in pairs and in correct order 
    You may assume the string includes not only '(' and ')', but also '[' and ']' and '{' and '}'   
    
    Parameters
    ----------
    s : a string
    
    Returns
    ----------
    True or False : boolean
    """

    # Implement me
    lefts, rights = ['(', '[', '{'], [')', ']', '}']
    stack = []

    for c in s:
        if c in rights:
            idx = rights.index(c)
            # If the parentheses are not in pairs or in correct order
            if (len(stack) == 0) or (lefts[idx] != stack.pop()):
                return False
        else:
            stack.append(c)

    return True if len(stack) == 0 else False

# Test
s_1 = "()"
s_2 = ")("
s_3 = "()()"
s_4 = "(())"

print(fun_45(s_1))
print(fun_45(s_2))
print(fun_45(s_3))
print(fun_45(s_4))

"""<a id='4.6'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 4.5](#4.5)
    - find an improved solution (in terms of the exact number of operations) by replacing the lists in [exercise 4.5](#4.5) with a dictioanry
    - the solution has the complexity below
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - using dictionary
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.6)
"""

def fun_46(s):
    """
    Check whether the parentheses in the input string are valid
    The parentheses are valid if they are always in pairs and in correct order 
    You may assume the string includes not only '(' and ')', but also '[' and ']' and '{' and '}'   
    
    Parameters
    ----------
    s : a string
    
    Returns
    ----------
    True or False : boolean
    """

    # Implement me
    parentheses = {')': '(', '}': '{', ']': '['}
    stack = []

    for c in s:
        if c in parentheses.keys():
            if (len(stack) == 0) or (parentheses[c] != stack.pop()):
                return False
        else:
            stack.append(c)

    return True if len(stack) == 0 else False

# Test
s_1 = "()"
s_2 = ")("
s_3 = "()()"
s_4 = "(())"

print(fun_46(s_1))
print(fun_46(s_2))
print(fun_46(s_3))
print(fun_46(s_4))

"""## Discussion
The difference in run time between the solution for the above two exercises can be seen in fig. 6. In general, when we want to find whether a number is in a collection, dictionary is a much better choice than list. This is because the time complexity are $O(1)$ and $O(n)$ (where $n$ is the size of the collection), when using dictionary and list, respectively.
"""

def plot(n, funs):
    """
    Plot the run time of the functions (with respect to the input size).
    
    Parameters
    ----------
    n : a number
    funs : a list of functions
    """
    
    x = list(range(n + 1))
    ys = [[] for _ in range(len(funs))]

    for i in x:
        for j in range(len(funs)):
            start = time.time()
            funs[j]('}' * i)
            end = time.time()
            ys[j].append(end - start)
    
    for j in range(len(funs)):
        plt.plot(x, ys[j], label=funs[j].__name__)
    plt.xlabel('$n$', fontsize=20)
    plt.ylabel('Run time', fontsize=20)
    plt.xticks([min(x), max(x)], fontsize=20)
    plt.yticks([min([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))]), max([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))])], fontsize=20)
    plt.legend(fontsize=20)
    plt.tight_layout()
    plt.show()

plot(10 ** 6, [fun_45, fun_46])
print("Figure 6. The run time of fun_45 and fun_46.")

"""<a id='4.8'></a>

## Exercise ($\star\star$)
- Problem:
    - evaluate an arithmetic expression in [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation)
    - you may assume all the numbers in the expression are integers
    - find the solution with the complexity below
    - this exercise will be followed by
        - [example 4.9](#4.9)
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - using stack
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.8)
"""

def fun_48(tokens):
    """
    Evaluate an arithmetic expression in Reverse Polish notation
    You may assume all the nubmers in the expression are intergers
    
    Parameters
    ----------
    tokens : a list of strings
    
    Returns
    ----------
    the value of the arithmetic expression : a number
    0 if "divide by zero"
    """

    # Implement me
    stack = []     

    for token in tokens:
        # If the token is an operator
        if token in ['+', '-', '*', '/']:
            # Pop the second operand
            b = stack.pop()
            # Pop the first operand
            a = stack.pop()
            if token == '+':
                # Push a + b
                stack.append(a + b)
            elif token == '-':
                # Push a - b
                stack.append(a - b)
            elif token == '*':
                # Push a * b
                stack.append(a * b)
            else:
                # Push a / b
                stack.append(a / b if b != 0 else 0)                        
        # If the token is an operand
        else:
            # Push the integer
            stack.append(int(token))

    return stack.pop()

# Test
arr_1 = ['2']
arr_2 = ['2', '3', '*']
arr_3 = ['2', '3', '*', '-4', '4', '+', '/']
arr_4 = ['2', '3', '*', '-4', '5', '6', '-7', '+', '-', '/']

print(fun_48(arr_1))
print(fun_48(arr_2))
print(fun_48(arr_3))
print(fun_48(arr_4))

"""<a id='4.9'></a>

## Example ($\star\star$)
- Problem:
    - follow up on [exercise 4.8](#4.8)
    - find an improved solution (in terms of speed and readability) by using the [lambda expression](https://docs.python.org/3/tutorial/controlflow.html)
    - the solution has the complexity below
- Complexity: 
    - $O(n)$ time
    - $O(n)$ space
- Skills:
    - using stack
    - using the [lambda expression](https://docs.python.org/3/tutorial/controlflow.html)
- Logic: see the comments below
"""

def fun_49(tokens):
    """
    Evaluate an arithmetic expression in Reverse Polish notation
    You may assume all the nubmers in the expression are intergers
    
    Parameters
    ----------
    tokens : a list of strings
    
    Returns
    ----------
    the value of the arithmetic expression : a number
    0 if "divide by zero"
    """
    
    operations = {'+': lambda x, y: x + y,
                  '-': lambda x, y: x - y,
                  '*': lambda x, y: x * y,
                  '/': lambda x, y: x / y if y != 0 else 0}

    stack = []     

    for token in tokens:
        # If the token is an operator
        if token in operations.keys():
            # Pop the second operand
            b = stack.pop()
            # Pop the first operand
            a = stack.pop()
            # Push a operator b
            stack.append(operations[token](a, b))
        # If the token is an operand
        else:
            # Push the integer
            stack.append(int(token))

    return stack.pop()

# Test
arr_1 = ['2']
arr_2 = ['2', '3', '*']
arr_3 = ['2', '3', '*', '-4', '4', '+', '/']
arr_4 = ['2', '3', '*', '-4', '5', '6', '-7', '+', '-', '/']

print(fun_49(arr_1))
print(fun_49(arr_2))
print(fun_49(arr_3))
print(fun_49(arr_4))

"""## Discussion
Compared to fun_48, fun_49 is more readable, since the operation with respect to each operator is defined in the dictionary (operations in fun_49) rather than in the for-loop (which is a little bit dazzling). Besides readability, fun_49 is theoretically faster then fun_48, for the same reason mentioned in discussion 4.7 (the difference between list and dictionary).

# Queue
In the previous section we introduced stack, which stores data in a LIFO (last in first out) fashion. We also discussed some applications of stack, for example, recursion ([example 4.2](#4.2)), parenthesis checking ([example 4.3](#4.3), [exercise 4.4](#4.4), [exercise 4.5](#4.5), [exercise 4.6](#4.6)), and expression evaluation ([exercise 4.8](#4.8) and [example 4.9](#4.9)). In this section we will introduce another data structure, named queue, which works in a somehow opposite way compared to stack. Since the queue data structure is much less popular than stack, we will only introduce its definition and basic operations.

## Definition
In simple words, *queue* is a structure where data are stored in a FIFO (first in first out) fashion. This is the key difference from stack (which works in a LIFO way). You can think of the queue data structure as the queue in real life. Most of the time, we wait in a queue (or a line) so that the customer who comes the first will be served the first (a.k.a., first come first serve). It would be chaotic if we waited in a stack instead.

There is another difference between stack and queue, on the programming level. As mentioned in section 4, we use list to implement stack. However, we do not do so for queue. This is because all the operations for stack (pushing and popping) are conducted from the end of the list. This is efficient since each operation takes $O(1)$ time. Conversely, if we used list to implement queue, the pushing operation is conducted from the end whereas the popping operation is conducted from the beginning. While the pushing operation takes $O(1)$ time, the popping takes $O(n)$ time.

For this reason, there is a data structure particularly designed for queue named deque. Here are some simple examples showing how deque works.
"""

from collections import deque

# Initialization
queue = deque([1, 2, 3, 4])
print('Initialization:', queue)

# Pushing
queue.append(5)
print('Pushing:', queue)

# Popping
queue.popleft()
print('Popping:', queue)

"""# Appendix

<a id='hints_3.4'></a>

## Hints for [exercise 3.4](#3.4):
- the logic is almost the same as that in [example 3.3](#3.3)
- the difference is
    - since we cannot assume the array is not empty (as suggested in the docstring), we need to tweak the code in [example 3.3](#3.3) to handle the corner case (i.e., the array is empty)
    - for example, we cannot assign the first element to max_ (as what we did in [example 3.3](#3.3))

<a id='hints_3.6'></a>

## Hints for [exercise 3.6](#3.6):
- the logic is almost the same as that in [example 3.5](#3.5)
- the difference is
    - after calculating the sum of subarray say, from $i$ to $k$, we do not have to do this again when calculating the sum of subarray from $i$ to $k + 1$
    - instead, we can simply add arr[k + 1] to the previous sum

<a id='hints_3.10'></a>

## Hints for [exercise 3.10](#3.10):
- the logic is almost the same as that in [example 3.8](#3.8)
- the difference is, instead of using an array (sum_arr in [example 3.8](#3.8)) to record the sum of the subarrays and get the largest sum in the end, we
    - use a variable (named local_max) to record the sum of the current subarray (ending at $i$)
    - use a variable (named global_max) to keep track of the largest sum along the way
- particularly, the logic for calculating local_max is exactly the same as that for calculating sum_arr[i] in [example 3.8](#3.8)

<a id='hints_3.12'></a>

## Hints for [exercise 3.12](#3.12):
- the logic is almost the same as that in [example 3.5](#3.5)
- the difference is we 
    - use two variables (named first_idx and last_idx) to record the index of the first and last element of the subarray that has the largest sum
    - update first_idx and last_idx when the largest sum (max_sum in [example 3.5](#3.5)) is updated

<a id='hints_3.13'></a>

## Hints for [exercise 3.13](#3.13):
- the logic is the same as that in [Hints for exercise 3.12](#hints_3.12)

<a id='hints_3.14'></a>

## Hints for [exercise 3.14](#3.14):
- the logic is almost the same as that in [example 3.8](#3.8)
- the difference is 
    - we use two variables (named first_idx and last_idx) to record the index of the first and last element of the subarray that has the largest sum
    - we update last_idx when the largest sum (max_sum in [example 3.8](#3.8)) is updated
    - after max_sum and last_idx have been found, first_idx can be identified easily
    - we can subtract max_sum by the element at last_idx and the ones on the left-hand side of it, until max_sum becomes zero
    - the index where we stop is first_idx

<a id='hints_3.15'></a>

## Hints for [exercise 3.15](#3.15):
- the logic is almost the same as that in [exercise 3.10](#3.10)
- the difference is we
    - use three variables (named first_idx, last_idx, and first_idx_temp) to record the index of the first and last element of the subarray that has the largest sum
    - update first_idx_temp when the sum of the subarray ending at $i$ (local_max in [exercise 3.10](#3.10)) equals arr[i]
    - update first_idx and last_idx when the largest sum (global_max in [exercise 3.10](#3.10)) is updated

<a id='hints_4.4'></a>

## Hints for [exercise 4.4](#4.4):
- the logic is almost the same as that in [example 4.3](#4.3)
- the difference is we
    - use a variable (named count) to record the difference between the number of '(' and ')'
    - return False if at any time count < 0 (parentheses are not in correct order)
    - return False if in the end count != 0 (parentheses are not in pairs) 
    - otherwise, return True

<a id='hints_4.5'></a>

## Hints for [exercise 4.5](#4.5):
- the logic is almost the same as that in [example 4.3](#4.3)
- the difference is we
    - need to match parentheses of the same kind since there are three kinds in this case

<a id='hints_4.6'></a>

## Hints for [exercise 4.6](#4.6):
- the logic is almost the same as that in [exercise 4.5](#4.5)
- the difference is
    - we replace the lists with a dictionary
    - the idea is that, when using a list:
        - the number of operations for checking whether the parenthesis (c in [exercise 4.5](#4.5)) being a right parenthesis (i.e., ')', ']', or '}') is 3
        - the number of operations for finding the corresponding left parenthesis is 4 (3 for getting the index (idx in [exercise 4.5](#4.5) and 1 for getting the parenthesis)
    - alternatively, when using a dictionary, the two number of operations are both 1
    - as a result, replacing the list with a dictionary lowers the number of operations from 7 (i.e., 3 + 4) to 2 (i.e., 1 + 1)

<a id='hints_4.8'></a>

## Hints for [exercise 4.8](#4.8):
- we loop over each string in the input list
- if the string is an operator, we pop the second and first operand off the stack and push the result (using the operator) into the stack
- if, on the other hand, the string is an operand, we push it into the stack
"""

