# -*- coding: utf-8 -*-
"""chapter_5_tree_search_solution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GYL54rhpqFqwHaiZ6T6KRTyAovkhSkvt

<h1>Table of Contents<span class="tocSkip"></span></h1>
<div class="toc"><ul class="toc-item"><li><span><a href="#Overview" data-toc-modified-id="Overview-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Overview</a></span></li><li><span><a href="#Learning-Objectives" data-toc-modified-id="Learning-Objectives-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Learning Objectives</a></span></li><li><span><a href="#Tree" data-toc-modified-id="Tree-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Tree</a></span><ul class="toc-item"><li><span><a href="#The-Definition" data-toc-modified-id="The-Definition-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>The Definition</a></span></li><li><span><a href="#The-Implementation-(of-Binary-Tree)" data-toc-modified-id="The-Implementation-(of-Binary-Tree)-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>The Implementation (of Binary Tree)</a></span></li><li><span><a href="#Tree-Traversal" data-toc-modified-id="Tree-Traversal-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>Tree Traversal</a></span><ul class="toc-item"><li><span><a href="#Pre-order-Traversal" data-toc-modified-id="Pre-order-Traversal-3.3.1"><span class="toc-item-num">3.3.1&nbsp;&nbsp;</span>Pre-order Traversal</a></span><ul class="toc-item"><li><span><a href="#The-Idea" data-toc-modified-id="The-Idea-3.3.1.1"><span class="toc-item-num">3.3.1.1&nbsp;&nbsp;</span>The Idea</a></span></li><li><span><a href="#Exercise-($\star\star$):-the-implementation" data-toc-modified-id="Exercise-($\star\star$):-the-implementation-3.3.1.2"><span class="toc-item-num">3.3.1.2&nbsp;&nbsp;</span>Exercise ($\star\star$): the implementation</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.3.1.3"><span class="toc-item-num">3.3.1.3&nbsp;&nbsp;</span>Discussion</a></span></li></ul></li><li><span><a href="#In-order-Traversal" data-toc-modified-id="In-order-Traversal-3.3.2"><span class="toc-item-num">3.3.2&nbsp;&nbsp;</span>In-order Traversal</a></span><ul class="toc-item"><li><span><a href="#The-Idea" data-toc-modified-id="The-Idea-3.3.2.1"><span class="toc-item-num">3.3.2.1&nbsp;&nbsp;</span>The Idea</a></span></li><li><span><a href="#Exercise-($\star\star$):-the-implementation" data-toc-modified-id="Exercise-($\star\star$):-the-implementation-3.3.2.2"><span class="toc-item-num">3.3.2.2&nbsp;&nbsp;</span>Exercise ($\star\star$): the implementation</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.3.2.3"><span class="toc-item-num">3.3.2.3&nbsp;&nbsp;</span>Discussion</a></span></li></ul></li><li><span><a href="#Post-order-Traversal" data-toc-modified-id="Post-order-Traversal-3.3.3"><span class="toc-item-num">3.3.3&nbsp;&nbsp;</span>Post-order Traversal</a></span><ul class="toc-item"><li><span><a href="#The-Idea" data-toc-modified-id="The-Idea-3.3.3.1"><span class="toc-item-num">3.3.3.1&nbsp;&nbsp;</span>The Idea</a></span></li><li><span><a href="#Exercise-($\star\star$):-the-implementation" data-toc-modified-id="Exercise-($\star\star$):-the-implementation-3.3.3.2"><span class="toc-item-num">3.3.3.2&nbsp;&nbsp;</span>Exercise ($\star\star$): the implementation</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-3.3.3.3"><span class="toc-item-num">3.3.3.3&nbsp;&nbsp;</span>Discussion</a></span></li></ul></li><li><span><a href="#Level-order-Traversal" data-toc-modified-id="Level-order-Traversal-3.3.4"><span class="toc-item-num">3.3.4&nbsp;&nbsp;</span>Level-order Traversal</a></span><ul class="toc-item"><li><span><a href="#Example-($\star\star\star$):-the-implementation" data-toc-modified-id="Example-($\star\star\star$):-the-implementation-3.3.4.1"><span class="toc-item-num">3.3.4.1&nbsp;&nbsp;</span>Example ($\star\star\star$): the implementation</a></span></li></ul></li></ul></li></ul></li><li><span><a href="#The-Idea-of-Depth-First-Search-and-Breadth-First-Search" data-toc-modified-id="The-Idea-of-Depth-First-Search-and-Breadth-First-Search-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>The Idea of Depth First Search and Breadth First Search</a></span></li><li><span><a href="#The-Application-of-DFS" data-toc-modified-id="The-Application-of-DFS-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>The Application of DFS</a></span><ul class="toc-item"><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.1"><span class="toc-item-num">5.1&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.2"><span class="toc-item-num">5.2&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-5.3"><span class="toc-item-num">5.3&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.4"><span class="toc-item-num">5.4&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.5"><span class="toc-item-num">5.5&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.6"><span class="toc-item-num">5.6&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.7"><span class="toc-item-num">5.7&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.8"><span class="toc-item-num">5.8&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-5.9"><span class="toc-item-num">5.9&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-5.10"><span class="toc-item-num">5.10&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li></ul></li><li><span><a href="#The-Application-of-BFS" data-toc-modified-id="The-Application-of-BFS-6"><span class="toc-item-num">6&nbsp;&nbsp;</span>The Application of BFS</a></span><ul class="toc-item"><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-6.1"><span class="toc-item-num">6.1&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-6.2"><span class="toc-item-num">6.2&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-6.3"><span class="toc-item-num">6.3&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-6.4"><span class="toc-item-num">6.4&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-6.5"><span class="toc-item-num">6.5&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-6.6"><span class="toc-item-num">6.6&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-6.7"><span class="toc-item-num">6.7&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-6.8"><span class="toc-item-num">6.8&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-6.9"><span class="toc-item-num">6.9&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-6.10"><span class="toc-item-num">6.10&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li></ul></li><li><span><a href="#Appendix" data-toc-modified-id="Appendix-7"><span class="toc-item-num">7&nbsp;&nbsp;</span>Appendix</a></span><ul class="toc-item"><li><span><a href="#Hints-for-exercise-5.1:" data-toc-modified-id="Hints-for-exercise-5.1:-7.1"><span class="toc-item-num">7.1&nbsp;&nbsp;</span>Hints for <a href="#5.1">exercise 5.1</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.2:" data-toc-modified-id="Hints-for-exercise-5.2:-7.2"><span class="toc-item-num">7.2&nbsp;&nbsp;</span>Hints for <a href="#5.2">exercise 5.2</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.3:" data-toc-modified-id="Hints-for-exercise-5.3:-7.3"><span class="toc-item-num">7.3&nbsp;&nbsp;</span>Hints for <a href="#5.3">exercise 5.3</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.4:" data-toc-modified-id="Hints-for-exercise-5.4:-7.4"><span class="toc-item-num">7.4&nbsp;&nbsp;</span>Hints for <a href="#5.4">exercise 5.4</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.5:" data-toc-modified-id="Hints-for-exercise-5.5:-7.5"><span class="toc-item-num">7.5&nbsp;&nbsp;</span>Hints for <a href="#5.5">exercise 5.5</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.6:" data-toc-modified-id="Hints-for-exercise-5.6:-7.6"><span class="toc-item-num">7.6&nbsp;&nbsp;</span>Hints for <a href="#5.6">exercise 5.6</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.7:" data-toc-modified-id="Hints-for-exercise-5.7:-7.7"><span class="toc-item-num">7.7&nbsp;&nbsp;</span>Hints for <a href="#5.7">exercise 5.7</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.8:" data-toc-modified-id="Hints-for-exercise-5.8:-7.8"><span class="toc-item-num">7.8&nbsp;&nbsp;</span>Hints for <a href="#5.8">exercise 5.8</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.9:" data-toc-modified-id="Hints-for-exercise-5.9:-7.9"><span class="toc-item-num">7.9&nbsp;&nbsp;</span>Hints for <a href="#5.9">exercise 5.9</a>:</a></span></li><li><span><a href="#Hints-for-exercise-5.10:" data-toc-modified-id="Hints-for-exercise-5.10:-7.10"><span class="toc-item-num">7.10&nbsp;&nbsp;</span>Hints for <a href="#5.10">exercise 5.10</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.1:" data-toc-modified-id="Hints-for-exercise-6.1:-7.11"><span class="toc-item-num">7.11&nbsp;&nbsp;</span>Hints for <a href="#6.1">exercise 6.1</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.2:" data-toc-modified-id="Hints-for-exercise-6.2:-7.12"><span class="toc-item-num">7.12&nbsp;&nbsp;</span>Hints for <a href="#6.2">exercise 6.2</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.3:" data-toc-modified-id="Hints-for-exercise-6.3:-7.13"><span class="toc-item-num">7.13&nbsp;&nbsp;</span>Hints for <a href="#6.3">exercise 6.3</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.4:" data-toc-modified-id="Hints-for-exercise-6.4:-7.14"><span class="toc-item-num">7.14&nbsp;&nbsp;</span>Hints for <a href="#6.4">exercise 6.4</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.5:" data-toc-modified-id="Hints-for-exercise-6.5:-7.15"><span class="toc-item-num">7.15&nbsp;&nbsp;</span>Hints for <a href="#6.5">exercise 6.5</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.6:" data-toc-modified-id="Hints-for-exercise-6.6:-7.16"><span class="toc-item-num">7.16&nbsp;&nbsp;</span>Hints for <a href="#6.6">exercise 6.6</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.7:" data-toc-modified-id="Hints-for-exercise-6.7:-7.17"><span class="toc-item-num">7.17&nbsp;&nbsp;</span>Hints for <a href="#6.7">exercise 6.7</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.8:" data-toc-modified-id="Hints-for-exercise-6.8:-7.18"><span class="toc-item-num">7.18&nbsp;&nbsp;</span>Hints for <a href="#6.8">exercise 6.8</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.9:" data-toc-modified-id="Hints-for-exercise-6.9:-7.19"><span class="toc-item-num">7.19&nbsp;&nbsp;</span>Hints for <a href="#6.9">exercise 6.9</a>:</a></span></li><li><span><a href="#Hints-for-exercise-6.10:" data-toc-modified-id="Hints-for-exercise-6.10:-7.20"><span class="toc-item-num">7.20&nbsp;&nbsp;</span>Hints for <a href="#6.10">exercise 6.10</a>:</a></span></li></ul></li></ul></div>

<b>

<p>
<center>
<font size="5">
Lecture Note for Computer Science Foundations (DATS 6450)
</font>
</center>
</p>

<p>
<center>
<font size="4">
Chapter 5: Tree and Search (Solution)
</font>
</center>
</p>

<p>
<center>
<font size="3">
Data Science, Columbian College of Arts & Sciences, George Washington University
</font>
</center>
</p>

<p>
<center>
<font size="3">
Author: Yuxiao Huang
</font>
</center>
</p>

</b>

# Overview
- We will discuss an advanced data structure (compared to the ones covered in chapter 2), named Tree
- Based on this data structure, we will discuss two kinds of search algorithms:
    - Depth First Search (DFS)
    - Breadth First Search (BFS)
- Particularly, the discussion of each algorithm can be divided into two parts:
    - theory, where we will describe the idea of the algorithm
    - coding
        - where (most of the time) we will start with some examples and then work on some exercises
        - particularly, the examples and exercises are organized in such a way that, an exercise (most of the time) is a follow-up on some example prior to it
        - **you should analyze the (time and space) complexity of each example and exercise**
- We will use stars to represent the difficulty of the exercises:
    - $\star$ means very easy
    - $\star\star$ means easy
    - $\star\star\star$ means medium
    - $\star\star\star\star$ means difficult
    - $\star\star\star\star\star$ means very difficult

# Learning Objectives
Students should know:
- the idea and implementation of tree
- how DFS and BFS work
- how to apply the two kinds of search algorithms to design optimal solutions (ones with the lowest complexity)

# Tree

## The Definition
While we have not formally defined the tree structure, we have been using it for a while. For example, in chapter 2 we used Recursion Tree to show the steps of calculating the Fibonacci Series. In chapter 3, we used Binary Search Tree to show the steps in Binary Search. These trees (as trees in real life) represent a hierarchical relationship between items.

More formally, a *Tree* data structure is a collection of nodes connected by directed (or sometimes undirected) edges. Each edge connects a parent (the node that the edge comes out of) and a child (the node that the edge goes into). While a node can have any number of children (including zero), it cannot have more than one parent. Particularly, based on the number of parent and children a node has, we can divide the nodes (in a tree) into three categories:
- root: the node that has no parent
- leaf: a node that has no children
- internal node: a node that is neither the root nor a leaf

<img src="../figure/figure_1.pdf" width="500" height="500">

Figure 1. The recursion tree for calculating the Fibonacci Series when $n = 5$.

In the recursion tree shown in fig. 1, the root is f(5) and the 0s and 1s are the leaves. The remaining nodes are the internal nodes.

There are two concepts that are sometimes used incorrectly: the depth of a node and the height of a node. Specifically, the *depth of a node* is the number of edges from the root to the node. The *height of a node*, on the other hand, is the number of edges from the node to the deepest leaf. The *height of a tree* is the height of the root. A tree with a single node (hence both a root and leaf) has depth and height zero. Conventionally, an empty tree (one with no nodes) has height −1. In fig. 1, the depth of f(5) is 0 (since f(5) is the root), and the height of f(5) is 5, which is also the height of the tree.

While a node in a tree can have any number of children, here we only focus on the case where a node has no more than two children. We call such tree a *Binary Tree*. An example of binary tree is shown in fig. 1, where each node has at most two children.

In chapter 3, we introduced a special case of binary tree, named *Binary Search Tree* (BST). A BST is a binary tree that satisfies all of the three following conditions:
- the left subtree of the root contains only nodes with value less than the value of the root
- the right subtree of the root contains only nodes with value larger than the value of the root
- both the left and right subtrees are BSTs

For example, fig. 2 shows the BST for input array [0, $\ldots$, 9].

<img src="../figure/figure_2.pdf" width="700" height="700">

Figure 2. The Binary Search Tree (BST) for input array [0, $\ldots$, 9].

## The Implementation (of Binary Tree)
As discussed earlier, a binary tree data structure is a collection of nodes (connected by edges) where each node has no more than two children. Such a tree node can be implemented as follows.
"""

class TreeNode(object):
    """The tree node class (for a binary tree)"""
    
    def __init__(self, x):
        # The value of the node
        self.val = x
        # The left child
        self.left = None
        # The right child
        self.right = None

"""The TreeNode class above has three attributes: the value of the node, the left child, and the right child. The value attribute is used to store the data (e.g., f(5) in fig. 1). The left and right child attributes are used to connect the node to its left and right children. The code blow creates the binary tree shown in fig. 3."""

# The root
root = TreeNode(0)

# The left and right child at depth 1
root.left = TreeNode(1)
root.right = TreeNode(2)

# The children at depth 2
root.left.left = TreeNode(3)
root.left.right = TreeNode(4)
root.right.left = TreeNode(5)
root.right.right = TreeNode(6)

"""<img src="../figure/figure_3.pdf" width="300" height="300">

Figure 3. A binary tree with 7 nodes.

## Tree Traversal 
It is worth noting that the tree in fig. 3 was not generated by python, but by [Graphviz](https://www.graphviz.org) from a dot file (where we manually specified the tree structure). A natural question is, can we write a piece of code to display a tree? The answer is, well, it depends. It could be a little bit difficult to generate a figure that looks as good as fig. 3. However, it is quite easy to produce something that we can work with. One such thing is the *Tree Traversal*, which shows us the (value of the) nodes in certain order. In this section, we will discuss four kinds of tree traversal, including: pre-order, in-order, post-order and level-order traversal. For each kind of traversal, we will discuss both the idea and implementation.

### Pre-order Traversal

#### The Idea
The pre-order traversal can be summarized as a recursive process:
- if the root is None (empty), return
- otherwise we:
    - display the value of the root
    - traverse the left subtree by recursively calling the pre-order function
    - traverse the right subtree by recursively calling the pre-order function

#### Exercise ($\star\star$): the implementation
- Problem:
    - based on the idea above, implement pre-order traversal
- Logic: see the idea above
"""

def pre_order(root):
    """
    Pre-order traversal 
    
    Parameters
    ----------
    root : the root of a binary tree
    """
    
    # Implement me
    # Base
    if root == None:
        return
    
    print(root.val, end=' ')
    
    # Recursion
    pre_order(root.left)
    pre_order(root.right)

# Test
pre_order(root)

"""#### Discussion
Can you explain the results above?

### In-order Traversal

#### The Idea
The in-order traversal is almost the same as pre-order traversal. The only difference is that, unlike in pre-order traversal where we display the root before traversing the left and right subtree, here we do so after traversing the left subtree but before traversing the right subtree. This can be summarized as a recursive process:
- if the root is None (empty), return
- otherwise we:
    - traverse the left subtree by recursively calling the in-order function
    - display the value of the root
    - traverse the right subtree by recursively calling the in-order function

#### Exercise ($\star\star$): the implementation
- Problem:
    - based on the idea above, implement in-order traversal
- Logic: see the idea above
"""

def in_order(root):
    """
    In-order traversal 
    
    Parameters
    ----------
    root : the root of a binary tree
    """
    
    # Implement me
    # Base
    if root == None:
        return
    
    # Recursion
    in_order(root.left)
    
    print(root.val, end=' ')
    
    # Recursion
    in_order(root.right)

# Test
in_order(root)

"""#### Discussion
Can you explain the results above?

### Post-order Traversal

#### The Idea
After the discussion of pre-order and in-order traversal, we are pretty sure that you can guess what the post-order traversal is about. Yes, you are right. Unlike in in-order traversal where we display the root after traversing the left subtree but before traversing the right subtree, here we do so after traversing both of the subtrees. This can be summarized as a recursive process:
- if the root is None (empty), return
- otherwise we:
    - traverse the left subtree by recursively calling the post-order function
    - traverse the right subtree by recursively calling the post-order function
    - display the value of the root

#### Exercise ($\star\star$): the implementation
- Problem:
    - based on the idea above, implement post-order traversal
- Logic: see the idea above
"""

def post_order(root):
    """
    Post-order traversal 
    
    Parameters
    ----------
    root : the root of a binary tree
    """

    # Implement me
    # Base
    if root == None:
        return
    
    # Recursion
    post_order(root.left)
    post_order(root.right)
    
    print(root.val, end=' ')

# Test
post_order(root)

"""#### Discussion
Can you explain the results above?

### Level-order Traversal
While the first three kinds of tree traversal differ in the order of displaying the (value of the) root node, there is one thing in common. That is, after visiting the root of each subtree we directly move on to its left child. Take the pre-order traversal for example, after visiting the root (node 0), we then visit its left child (1), then the left child of its left child (3), which is a leaf node. This is the reason why the first three number in the output of pre-order traversal are 0, 1, and 3.

Here we introduce another approach for tree traversal, *Level-order Traversal*, which (as suggested by the name) traverses the nodes level by level. This can be summarized as an iterative process:
- for depth from 0 to the height of the tree
    - we traverse the nodes with the corresponding depth from left to right
    - this can be done using the queue structure discussed in chapter 2

#### Example ($\star\star\star$): the implementation
- Problem:
    - based on the idea above, implement level-order traversal
- Logic: see the idea above
"""

from collections import deque

def level_order(root):
    """
    Level-order traversal 
    
    Parameters
    ----------
    root : the root of a binary tree
    """

    # Corner case
    if root == None:
        return

    # Initialize the queue
    queue = deque([root])
    
    # Level order traversal
    while len(queue) > 0:
        # Get the length of the queue
        # n = len(queue)    
        # for _ in range(n):
        for _ in range(len(queue))
            # Remove the first node in the queue
            node = queue.popleft()            
            if node != None:
                print(node.val, end=' ')
                # Add the left and right children to the end of the queue
                queue.append(node.left)
                queue.append(node.right)
        print()

# Test
level_order(root)

"""# The Idea of Depth First Search and Breadth First Search
Previously we discussed the idea and implementation of binary tree and its traversal. Particularly, we introduced four kinds of tree traversal algorithms, including: pre-order, in-order, post-order and level-order traversal. The first three algorithms visit the nodes in such a way that, after vising the root of the tree they directly move on to its children. Level-order traversal, on the other hand, visits the nodes level by level.

It turns out that the four kinds of traversals represent two kinds of searching algorithms. Specifically, pre-order, in-order and post-order traversal represent a searching algorithm called *Depth First Search* (DFS). If you think about it, the name makes sense since all the three traversals start at the root and go down a path as far as they can. On the other hand, level-order traversal represents a searching algorithm called *Breadth First Search* (BFS). The name also makes sense, since the traversal starts at the root and explores all the nodes with the present depth prior to moving on to the nodes at the next depth level.

# The Application of DFS
In this section, we will discuss how to apply DFS to solve some searching problems.

<a id='5.1'></a>

## Exercise ($\star\star$)
- Problem:
    - find the height of a binary tree
    - as mentioned in sec. 3.1
        - the height of a tree is the number of edges from the root to the deepest leaf
        - a tree with a single node (hence both a root and leaf) has depth and height zero
        - an empty tree (one with no nodes) has height −1
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.1](#6.1)
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.1)
"""

# Implementation
def fun_51(root):
    """
    Find the height of a binary tree
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The height of the tree : an integer
    """
    
    # Implement me
    # Base
    if root == None:
        return -1
    
    # Recursion
    return max(fun_51(root.left), fun_51(root.right)) + 1

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)
root3.right = TreeNode(2)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(2)
root4.left.left = TreeNode(3)

print(fun_51(root1))
print(fun_51(root2))
print(fun_51(root3))
print(fun_51(root4))

"""<a id='5.2'></a>

## Exercise ($\star\star$)
- Problem:
    - find whether two binary trees are the same
    - here, two trees are considered the same if they have the same structure and the same nodes
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 5.3](#5.3)
        - [exercise 6.2](#6.2)
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.2)
"""

# Implementation
def fun_52(root1, root2):
    """
    Find whether two binary trees are the same
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the trees are the same
    False, otherwise
    """
    
    # Implement me
    # Base
    if root1 == None and root2 == None:
        return True
        
    # Base
    if root1 == None or root2 == None:
        return False
       
    # Recursion
    return (root1.val == root2.val 
            and fun_52(root1.left, root2.left) 
            and fun_52(root1.right, root2.right))

# Test
root1 = None
root2 = None

root3 = None
root4 = TreeNode('0')

root5 = TreeNode('0')
root6 = TreeNode('0')

root7 = TreeNode('0')
root7.left = TreeNode('1')
root8 = TreeNode('0')
root8.right = TreeNode('1')

print(fun_52(root1, root2))
print(fun_52(root3, root4))
print(fun_52(root5, root6))
print(fun_52(root7, root8))

"""<a id='5.3'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 5.2](#5.2)
    - check whether a binary tree is symmetric (i.e., mirror of itself)
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.6](#6.6)
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.3)
"""

# Implementation
def fun_53(root):
    """
    Check whether a binary tree is symmetric (i.e., mirror of itself)    
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the tree is symmetric
    False, otherwise
    """
    
    # Implement me
    # Base
    if root == None:
        return True

    # Recursion
    return True if helper(root.left, root.right) else False

def helper(left, right):
    """
    Check whether the left subtree is the mirror of the right subtree 
    
    Parameters
    ----------
    left : the root of the left subtree
    right : the root of the right subtree
    
    Returns
    ----------
    True, if the left subtree is the mirror of the right subtree 
    False, otherwise
    """
    
    # Implement me
    # Base
    if left == None and right == None:
        return True

    # Base
    if left == None or right == None:
        return False

    # Base
    if left.val != right.val:
        return False

    # Recursion
    return True if helper(left.left, right.right) and helper(left.right, right.left) else False

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(1)

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(2)
root5.right = TreeNode(1)
root5.right.left = TreeNode(2)

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(2)
root6.right = TreeNode(1)
root6.right.right = TreeNode(2)

print(fun_53(root1))
print(fun_53(root2))
print(fun_53(root3))
print(fun_53(root4))
print(fun_53(root5))
print(fun_53(root6))

"""<a id='5.4'></a>

## Exercise ($\star\star$)
- Problem:
    - find whether two binary trees have the same sequence of leaves
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.7](#6.7)
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.4)
"""

# Implementation
def fun_54(root1, root2):
    """
    Find whether two binary trees have the same sequence of leaves
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the trees have the same sequence of leaves
    False, otherwise
    """
    
    # Implement me
    return helper(root1) == helper(root2)

def helper(root):
    """
    Find the sequence of leaves of a tree
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The sequence of leaves : a list
    """
    
    # Implement me
    # Base
    if root == None:
        return []

    # Base
    if root.left == None and root.right == None:
        return [root.val]

    # Recursion
    return helper(root.left) + helper(root.right)

# Test
root1 = None
root2 = None

root3 = None
root4 = TreeNode('0')

root5 = TreeNode('0')
root6 = TreeNode('0')

root7 = TreeNode('0')
root7.left = TreeNode('1')
root8 = TreeNode('0')
root8.right = TreeNode('1')

print(fun_54(root1, root2))
print(fun_54(root3, root4))
print(fun_54(root5, root6))
print(fun_54(root7, root8))

"""<a id='5.5'></a>

## Exercise ($\star\star$)
- Problem:
    - find the paths (from the root to a leaf) of a binary tree 
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
    - using helper function to avoid redundancy
    - string operations
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.5)
"""

# Implementation
def fun_55(root):
    """
    Find the paths (from the root to a leaf) of a binary tree   
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The paths
    """
    
    # Implement me
    global paths      
    paths = []

    helper(root, '')
    return paths

def helper(root, path):
    """
    Find the paths (from the root to a leaf) of a binary tree   
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The paths
    """

    # Implement me
    # Base
    if root == None:
        return

    # Base
    if root.left == None and root.right == None:
        # Add the value of the root to path        
        path += str(root.val)
        # Append path to paths
        paths.append(path)
        return
    # Recursion
    else:
        # Add the value of the root and the arrow ('->') to path
        path += str(root.val) + '->'   
        helper(root.left, path)
        helper(root.right, path)

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(1)

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(2)
root5.right = TreeNode(1)
root5.right.left = TreeNode(2)

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(2)
root6.right = TreeNode(1)
root6.right.right = TreeNode(2)

print(fun_55(root1))
print(fun_55(root2))
print(fun_55(root3))
print(fun_55(root4))
print(fun_55(root5))
print(fun_55(root6))

"""<a id='5.6'></a>

## Exercise ($\star\star$)
- Problem:
    - find whether a binary tree is a Binary Search Tree (BST)
    - as discussed in section 3.1, a BST is a binary tree that satisfies all of the three following conditions:
        - the left subtree of the root contains only nodes with value less than the value of the root
        - the right subtree of the root contains only nodes with value larger than the value of the root
        - both the left and right subtrees are BSTs
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 5.8](#5.8)
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.6)
"""

# Implementation
def fun_56(root):
    """
    Find whether a binary tree is a Binary Search Tree (BST)
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the tree is a BST
    False, otherwise
    """
    
    # Implement me
    # Base
    if root == None:
        return True
        
    return helper(root.left, float("-inf"), root.val) and helper(root.right, root.val, float("inf"))

def helper(root, min_, max_):
    """
    Find whether a binary tree is a Binary Search Tree (BST)
    
    Parameters
    ----------
    root : the root of a binary tree
    min_ : the lower bound of the value of the tree
    max_ : the upper bound of the value of the tree
    
    Returns
    ----------
    True, if the tree is a BST
    False, otherwise
    """
    
    # Implement me
    # Base
    if root == None:
        return True

    # Base
    if root.val <= min_ or root.val >= max_:
        return False

    # Recursion
    return helper(root.left, min_, root.val) and helper(root.right, root.val, max_)

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(-1)

root4 = TreeNode(0)
root4.left = TreeNode(-1)
root4.right = TreeNode(1)

root5 = TreeNode(0)
root5.left = TreeNode(-1)
root5.left.left = TreeNode(-2)
root5.right = TreeNode(1)
root5.right.left = TreeNode(2)

root6 = TreeNode(0)
root6.left = TreeNode(-1)
root6.left.left = TreeNode(2)
root6.right = TreeNode(1)
root6.right.right = TreeNode(-2)

print(fun_56(root1))
print(fun_56(root2))
print(fun_56(root3))
print(fun_56(root4))
print(fun_56(root5))
print(fun_56(root6))

"""<a id='5.7'></a>

## Exercise ($\star\star$)
- Problem:
    - build a height-balanced binary tree from an array
    - here:
        - an empty binary tree is balanced
        - a non-empty binary tree is balanced if all of the following three conditions hold:
            - the left subtree is balanced
            - the right subtree is balanced
            - the difference between the height of left and right subtree is no more than 1
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 5.8](#5.8)
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.7)
"""

# Implementation
def fun_57(arr):
    """
    Build a height-balanced binary tree from an array
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    A height-balanced binary tree
    """
    
    # Implement me
    # Base
    if len(arr) == 0:
        return None

    # Create the root
    mid = len(arr) // 2
    root = TreeNode(arr[mid])

    # Recursion
    root.left, root.right = fun_57(arr[:mid]), fun_57(arr[mid + 1:])

    return root

# Test
arr_1 = [2]
arr_2 = [4]
arr_3 = [2, 3, 4]
arr_4 = [2, 3, 4, 5, 6, 7, 8]

level_order(fun_57(arr_1))
level_order(fun_57(arr_2))
level_order(fun_57(arr_3))
level_order(fun_57(arr_4))

"""<a id='5.8'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 5.7](#5.7) (and [exercise 5.6](#5.6))
    - unlike in [exercise 5.7](#5.7) where you should build a height-balanced binary tree from an array, here you should build a height-balanced binary search tree (BST) from a sorted array (in ascending order)
    - see the definition of BST and height-balanced binary tree in [exercise 5.6](#5.6) and [exercise 5.7](#5.7)
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.8)
"""

# Implementation
def fun_58(arr):
    """
    Build a height-balanced binary search tree from a sorted array (in ascending order)
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    A height-balanced binary search tree
    """
    
    # Implement me
    # Base
    if len(arr) == 0:
        return None

    # Create the root
    mid = len(arr) // 2
    root = TreeNode(arr[mid])

    # Recursion
    root.left, root.right = fun_57(arr[:mid]), fun_57(arr[mid + 1:])

    return root

# Test
arr_1 = [2]
arr_2 = [4]
arr_3 = [2, 3, 4]
arr_4 = [2, 3, 4, 5, 6, 7, 8]


level_order(fun_58(arr_1))
level_order(fun_58(arr_2))
level_order(fun_58(arr_3))
level_order(fun_58(arr_4))

"""<a id='5.9'></a>

## Exercise ($\star\star$)
- Problem:
    - find the total number of [kaggle competitions](https://www.kaggle.com/competitions) a student and their friends at Data Science have taken
    - here, a student's information is a list of three elements:
        - id
        - number of kaggle competitions the student has taken
        - the list of the student's friends
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
    - using helper function to avoid redundancy
    - using dictionaries
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.9)
"""

# Implementation
def fun_59(students, id):
    """
    Find the total number of kaggle competitions a student and their friends at Data Science have taken
    
    Parameters
    ----------
    students : a list of [id, number of competitions, friends' id]
    id : the id of a student
    
    Returns
    ----------
    the total number of kaggle competitions someone and their friends have taken : an integer
    """

    # Implement me
    # Create a dictionary where the keys are id and values are [number of competitions, friends' id]
    dict_ = {}
    for student in students:
        if len(student) == 3:
            # Get the id of the student, number of competitions, and friends' id
            id_, num, ids = student
            # Update the dictionary
            dict_[id_] = [num, ids]
        
    return helper(dict_, id)

def helper(dict_, id):
    """
    Find the total number of kaggle competitions a student and their friends at Data Science have taken
    
    Parameters
    ----------
    students : a dictionary where the keys are id and values are [number of competitions, friends' id]
    id : the id of a student
    
    Returns
    ----------
    the total number of kaggle competitions someone and their friends have taken : an integer
    """

    # Implement me
    if id not in dict_:
        return 0
    
    num = dict_[id][0]
    dict_[id][0] = -1
    
    return num + sum([helper(dict_, id_) for id_ in dict_[id][1] if dict_[id_][0] != -1])

# Test
students1 = []
id1 = 0

students2 = [[]]
id2 = 0

students3 = [[0, 1, []]]
id3 = 0

students4 = [[0, 1, [1]],
             [1, 2, [0]],
             [2, 3, []]]
id4 = 0

students5 = [[0, 1, [1, 2]],
             [1, 2, [0]],
             [2, 3, [0]]]
id5 = 1

print(fun_59(students1, id1))
print(fun_59(students2, id2))
print(fun_59(students3, id3))
print(fun_59(students4, id4))
print(fun_59(students5, id5))

"""<a id='5.10'></a>

## Exercise ($\star\star\star$)
- Problem:
    - find the number of (vertically or horizontally) connected deserts in a map
    - here, the map is represented by a matrix (2d array), where 1 denotes desert and 0 denotes grassland
    - for example
        - there is one connected desert in matrix [[1, 1], [0, 1]]   
        - there are two connected deserts in matrix [[1, 0], [0, 1]]   
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - DFS
    - using recursion to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_5.10)
"""

# Implementation
def fun_510(matrix):
    """
    Find the number of (vertically or horizontally) connected deserts in a map (represented by a matrix)
    
    Parameters
    ----------
    matrix : a matrix where 1 denotes desert and 0 denotes grassland
    
    Returns
    ----------
    the number of connected deserts
    """

    # Implement me
    if len(matrix) == 0 or len(matrix[0]) == 0:
        return 0

    m, n = len(matrix), len(matrix[0])
    # The number of connected deserts
    count = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                count += 1
                # DFS: remove '1's conntected to entry [i, j]
                helper(matrix, m, n, i, j)

    return count

def helper(matrix, m, n, i, j):
    """
    DFS: remove '1's conntected to entry [i, j]

    Parameters
    ----------
    matrix : a matrix where 1 denotes desert and 0 denotes grass land
    m : the nubmer of rows in the matrix
    n : the nubmer of columns in the matrix
    i, j : entry [i, j]
    """

    # Implement me
    # If either i or j is not valid, or matrix[i][j] is not 1
    if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] != 1:
        return

    # Remove 1
    matrix[i][j] = 0

    # Remove '1' above [i, j]
    helper(matrix, m, n, i - 1, j)
    # Remove '1' below [i, j]
    helper(matrix, m, n, i + 1, j)
    # Remove '1' on the left-hand side of [i, j]
    helper(matrix, m, n, i, j - 1)
    # Remove '1' on the right-hand side of [i, j]
    helper(matrix, m, n, i, j + 1)

# Test
matrix1 = []
matrix2 = [[]]
matrix3 = [[1]]
matrix4 = [[1, 1],
           [0, 1]]
matrix5 = [[1, 0],
           [0, 1]]
matrix6 = [[1, 0, 0],
           [0, 1, 0],
           [0, 0, 1]]
matrix7 = [[1, 1, 0],
           [0, 1, 0],
           [0, 0, 1]]
matrix8 = [[1, 1, 1],
           [0, 1, 0],
           [0, 0, 1]]
matrix9 = [[1, 1, 0],
           [0, 1, 0],
           [1, 0, 1]]
matrix10 = [[1, 1, 0],
            [1, 1, 0],
            [1, 0, 1]]

print(fun_510(matrix1))
print(fun_510(matrix2))
print(fun_510(matrix3))
print(fun_510(matrix4))
print(fun_510(matrix5))
print(fun_510(matrix6))
print(fun_510(matrix7))
print(fun_510(matrix8))
print(fun_510(matrix9))
print(fun_510(matrix10))

"""# The Application of BFS
In the previous section, we discussed how to use DFS to solve problems. Here, we will apply BFS to do so. Particularly, some of the problems in this section are the same as those in the previous section. By doing this, we want to show that DFS and BFS could be suitable for different problems.

<a id='6.1'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 5.1](#5.1)
    - find the height of a binary tree
    - unlike in [exercise 5.1](#5.1) where we use DFS to design a recursive solution, here we use BFS to design an iterative solution
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.1)
"""

# Implementation
def fun_61(root):
    """
    Find the height of a binary tree    
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The height of the tree : an integer
    """

    # Implement me
    # Corner case
    if root == None:
        return -1

    # Initialize the queue
    queue = deque([root])
    # Initialize the height
    height = -1

    # BFS
    while len(queue) > 0:
        # Update height
        height += 1

        n = len(queue)    
        for _ in range(n):
            # Remove the first node in the queue
            node = queue.popleft()
            
            if node.left != None:
                # Add the left child to the end of the queue
                queue.append(node.left)
            if node.right != None:
                # Add the right child to the end of the queue
                queue.append(node.right)

    return height

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)
root3.right = TreeNode(2)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(2)
root4.left.left = TreeNode(3)

print(fun_61(root1))
print(fun_61(root2))
print(fun_61(root3))
print(fun_61(root4))

"""<a id='6.2'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 5.2](#5.2)
    - find whether two binary trees are the same
    - unlike in [exercise 5.2](#5.2) where we use DFS to design a recursive solution, here we use BFS to design an iterative solution
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.3](#6.3)
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.2)
"""

# Implementation
def fun_62(root1, root2):
    """
    Find whether two binary trees are the same
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the trees are the same
    False, otherwise
    """
    
    # Implement me
    return helper(root1) == helper(root2)

def helper(root):
    """
    Level-order traversal that includes None (empty node) in the traversal
    
    Parameters
    ----------
    root : the root of a binary tree
    """

    # Implement me
    # Corner case
    if root == None:
        return

    # Initialize the queue
    queue = deque([root])
    # Initialize the list
    vals = []
    
    # Level order traversal
    while len(queue) > 0:
        # Get the length of the queue
        n = len(queue)    
        for _ in range(n):
            # Remove the first node in the queue
            node = queue.popleft()            
            if node != None:
                vals.append(node.val)
                # Add the left and right children to the end of the queue
                queue.append(node.left)
                queue.append(node.right)
            else:
                # Include None
                vals.append(None)
                
    return vals

# Test
root1 = None
root2 = None

root3 = None
root4 = TreeNode('0')

root5 = TreeNode('0')
root6 = TreeNode('0')

root7 = TreeNode('0')
root7.left = TreeNode('1')
root8 = TreeNode('0')
root8.right = TreeNode('1')

print(fun_62(root1, root2))
print(fun_62(root3, root4))
print(fun_62(root5, root6))
print(fun_62(root7, root8))

"""<a id='6.3'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 6.2](#6.2)
    - find whether two binary trees are the same
    - unlike in [exercise 6.2](#6.2) where we complete the level-order traversal of both trees and then compare the traversals, here we compare the traversal of each level of the two trees and terminate the algorithm as soon as the traversals are different
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.4](#6.4)
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.3)
"""

# Implementation
def fun_63(root1, root2):
    """
    Find whether two binary trees are the same
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the trees are the same
    False, otherwise
    """
    
    # Implement me    
    # Corner case
    if root1 == None and root2 == None:
        return True
    
    # Corner case
    if root1 == None or root2 == None:
        return False
    
    # Initialize the queues
    queue1, queue2 = deque([root1]), deque([root2])
    
    # Level order traversal
    while len(queue1) > 0 and len(queue2) > 0:
        if helper(queue1) != helper(queue2):
            return False     
    
    return len(queue1) == len(queue2)

def helper(queue):
    """
    Level-order traversal that includes None (empty node) in the traversal
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The value of the nodes on a level
    """

    # Implement me
    # Get the length of the queue
    n = len(queue)
    
    # The value of the nodes on a level
    vals = []
    
    for _ in range(n):
        # Remove the first node in the queue
        node = queue.popleft()

        if node == None:
            vals.append(None)
        else:
            vals.append(node.val)
            # Add the left and right children to the end of the queue
            queue.append(node.left)
            queue.append(node.right)
            
    return vals

# Test
root1 = None
root2 = None

root3 = None
root4 = TreeNode('0')

root5 = TreeNode('0')
root6 = TreeNode('0')

root7 = TreeNode('0')
root7.left = TreeNode('1')
root8 = TreeNode('0')
root8.right = TreeNode('1')

print(fun_63(root1, root2))
print(fun_63(root3, root4))
print(fun_63(root5, root6))
print(fun_63(root7, root8))

"""<a id='6.4'></a>

## Exercise ($\star\star$)
- Problem:
    - follow up on [exercise 6.3](#6.3)
    - find whether two binary trees are the same
    - unlike in [exercise 6.3](#6.3) where we complete the traversal of each level of the two trees, here we compare the node on each level of the two trees and terminate the algorithm as soon as the nodes are different
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.4)
"""

# Implementation
def fun_64(root1, root2):
    """
    Find whether two binary trees are the same
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    True, if the trees are the same
    False, otherwise
    """
    
    # Implement me    
    # Corner case
    if helper(root1, root2) is False:
        return False
    
    # Corner case
    if root1 == None and root2 == None:
        return True
    
    # Initialize the queues
    queue1, queue2 = deque([root1]), deque([root2])
    
    # Level order traversal
    while len(queue1) > 0 and len(queue2) > 0:
        node1, node2 = queue1.popleft(), queue2.popleft()

        if (helper(node1, node2) is False
            or helper(node1.left, node2.left) is False
            or helper(node1.right, node2.right) is False):
                return False

        if node1.left != None:
            queue1.append(node1.left)
            queue2.append(node2.left)
        if node1.right != None:
            queue1.append(node1.right)
            queue2.append(node2.right)            
    
    return len(queue1) == len(queue2)

def helper(node1, node2):
    """
    Find whether two nodes are the same
    
    Parameters
    ----------
    node1 : one node in a binary tree
    node2 : the other node in a binary tree
    """

    # Implement me
    if node1 == None and node2 == None:
        return True

    if node1 == None or node2 == None:
        return False
    
    if node1.val == node2.val:
        return True
    else:
        return False

# Test
root1 = None
root2 = None

root3 = None
root4 = TreeNode('0')

root5 = TreeNode('0')
root6 = TreeNode('0')

root7 = TreeNode('0')
root7.left = TreeNode('1')
root8 = TreeNode('0')
root8.right = TreeNode('1')

print(fun_64(root1, root2))
print(fun_64(root3, root4))
print(fun_64(root5, root6))
print(fun_64(root7, root8))

"""<a id='6.5'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 5.3](#5.3)
    - check whether a binary tree is symmetric (i.e., mirror of itself)
    - unlike in [exercise 5.3](#5.3) where we use DFS to design a recursive solution, here we use BFS to design an iterative solution
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.6](#6.6)
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.5)
"""

# Implementation
def fun_65(root):
    """
    Check whether a binary tree is symmetric (i.e., mirror of itself)    
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    True, if the binary is symmetric
    False, otherwise
    """

    # Implement me
    # Corner case
    if root == None:
        return True

    # Initialize the queue
    queue = deque([root])
    
    # BFS
    while len(queue) > 0:
        vals = []

        n = len(queue) 
        for _ in range(n):           
            # Remove the first node in the queue
            node = queue.popleft()
            
            if node == None:
                vals.append(None)
            else:
                vals.append(node.val)
                queue.append(node.left)
                queue.append(node.right)
                
        # Check if the level is symmetric
        left, right = 0, n - 1
        while left < right:
            if vals[left] != vals[right]:
                return False
            left += 1
            right -= 1

    return True

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(1)

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(2)
root5.right = TreeNode(1)
root5.right.left = TreeNode(2)

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(2)
root6.right = TreeNode(1)
root6.right.right = TreeNode(2)

print(fun_65(root1))
print(fun_65(root2))
print(fun_65(root3))
print(fun_65(root4))
print(fun_65(root5))
print(fun_65(root6))

"""<a id='6.6'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 6.5](#6.5)
    - check whether a binary tree is symmetric (i.e., mirror of itself)
    - unlike in [exercise 6.5](#6.5) where we use a list to keep track of the value of nodes on each level, here we do not use the list (thus saving O(n) extra space)
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.6)
"""

# Implementation
def fun_66(root):
    """
    Check whether a binary tree is symmetric (i.e., mirror of itself)    
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    True, if the binary is symmetric
    False, otherwise
    """

    # Implement me
    # Corner case
    if root == None:
        return True

    # Initialize the queue
    queue = deque([root.left, root.right])
    
    # BFS
    while len(queue) > 0:
        # Remove the first two nodes in the queue
        # They are symmetric in the tree (in terms of their positions)
        node_left, node_right = queue.popleft(), queue.popleft()

        if node_left == None and node_right == None:
            continue
        elif node_left == None or node_right == None:
            return False
        elif node_left.val != node_right.val:
            return False

        # Add their symmetric children to the end of the queue
        queue.append(node_left.left)
        queue.append(node_right.right)
        queue.append(node_left.right)
        queue.append(node_right.left)

    return True

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(1)

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(2)
root5.right = TreeNode(1)
root5.right.left = TreeNode(2)

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(2)
root6.right = TreeNode(1)
root6.right.right = TreeNode(2)

print(fun_66(root1))
print(fun_66(root2))
print(fun_66(root3))
print(fun_66(root4))
print(fun_66(root5))
print(fun_66(root6))

"""<a id='6.7'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 5.4](#5.4)
    - find whether two binary trees have the same sequence of leaves
    - unlike in [exercise 5.4](#5.4) where we use DFS to design a recursive solution, here we use BFS to design an iterative solution
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
    - using helper function to avoid redundancy
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.7)
"""

# Implementation
def fun_67(root1, root2):
    """
    Find whether two binary trees have the same sequence of leaves
    
    Parameters
    ----------
    root1 : the root of one binary tree
    root2 : the root of the other binary tree
    
    Returns
    ----------
    True, if the trees have the same sequence of leaves
    False, otherwise
    """
    
    # Implement me
    return helper(root1) == helper(root2)

def helper(root):
    """
    Find the sequence of leaves of a tree
    
    Parameters
    ----------
    root : the root of a binary tree
    
    Returns
    ----------
    The sequence of leaves : a list
    """
    
    # Implement me    
    vals = []
    
    # Corner case
    if root == None:
        return vals
    
    # Initialize the queue
    queue = deque([root])
    
    # BFS
    while len(queue) > 0:
        # Get the length of the queue
        n = len(queue)
        for _ in range(n):
            # Remove the first node in the queue
            node = queue.popleft()
            
            if node.left == None and node.right == None:
                vals.append(node.val)
            else:
                if node.left != None:
                    # Add the left and right children to the end of the queue
                    queue.append(node.left)
                if node.right != None:
                    # Add the left and right children to the end of the queue
                    queue.append(node.right)
                
    return vals

# Test
root1 = None
root2 = None

root3 = None
root4 = TreeNode('0')

root5 = TreeNode('0')
root6 = TreeNode('0')

root7 = TreeNode('0')
root7.left = TreeNode('1')
root8 = TreeNode('0')
root8.right = TreeNode('1')

print(fun_67(root1, root2))
print(fun_67(root3, root4))
print(fun_67(root5, root6))
print(fun_67(root7, root8))

"""<a id='6.8'></a>

## Exercise ($\star\star\star$)
- Problem:
    - check whether two nodes in a binary tree are on the same level (i.e., have the same depth)
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 6.9](#6.9)
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
    - using dictionary to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.8)
"""

# Implementation
def fun_68(root, x, y):
    """
    Check whether two nodes in a binary tree are on the same level (i.e., have the same depth)    
    
    Parameters
    ----------
    root : the root of a tree
    x : the value of a node
    y : the value of another node
    
    Returns
    ----------
    True, if the two nodes are on the same level
    False, otherwise
    """

    # Implement me
    # Corner case
    if root == None:
        return True

    # Initialize the queue
    queue = deque([root])

    # BFS
    while len(queue) > 0:
        dict_ = {}

        # Get the length of the queue
        n = len(queue)
        for i in range(n):
            # Remove the first node in the queue
            node = queue.popleft()
            if node.left != None:
                # Add the left child to the end of the queue
                queue.append(node.left)
                # Add the value of the left child to the dictionary as a key
                dict_[node.left.val] = 1
            if node.right != None:
                # Add the right child to the end of the queue
                queue.append(node.right)
                # Add the value of the right child to the dictionary as a key
                dict_[node.right.val] = 1    

            # Both x and y are in the dictionary (i.e., they are on the same level)
            if x in dict_ and y in dict_:
                return True

    return False

# Test
root1 = None
x1, y1 = 0, 1

root2 = TreeNode(0)
x2, y2 = 0, 1

root3 = TreeNode(0)
root3.left = TreeNode(1)
x3, y3 = 0, 1

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(2)
x4, y4 = 1, 2

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(3)
root5.right = TreeNode(2)
root5.right.left = TreeNode(4)
x5, y5 = 1, 2

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(3)
root6.right = TreeNode(2)
root6.right.right = TreeNode(4)
x6, y6 = 3, 4

print(fun_68(root1, x1, y1))
print(fun_68(root2, x2, y2))
print(fun_68(root3, x3, y3))
print(fun_68(root4, x4, y4))
print(fun_68(root5, x5, y5))
print(fun_68(root6, x6, y6))

"""<a id='6.9'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 6.8](#6.8)
    - unlike in [exercise 6.8](#6.8) where we only check whether two nodes in a binary tree are on the same level, here we also check whether they have different parents
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
    - using dictionary to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.9)
"""

# Implementation
def fun_69(root, x, y):
    """
    Check whether two nodes in a binary tree 1) are on the same level, and 2) have different parents
    
    Parameters
    ----------
    root : the root of a tree
    x : the value of a node
    y : the value of another node
    
    Returns
    ----------
    True, if the two nodes are on the same level but have different parents
    False, otherwise
    """

    # Implement me
    # Corner case
    if root == None:
        return True

    # Initialize the queue
    queue = deque([root])

    # BFS
    while len(queue) > 0:
        dict_ = {}

        # Get the length of the queue
        n = len(queue)
        for i in range(n):
            # Remove the first node in the queue
            node = queue.popleft()
            if node.left != None:
                # Add the left child to the end of the queue
                queue.append(node.left)
                # Add the value of the left child to the dictionary as a key
                dict_[node.left.val] = node.val
            if node.right != None:
                # Add the right child to the end of the queue
                queue.append(node.right)
                # Add the value of the right child to the dictionary as a key
                dict_[node.right.val] = node.val

            # both x and y are in the dictionary (i.e., they are on the same level)
            # and the two nodes have different parents
            if x in dict_ and y in dict_ and dict_[x] != dict_[y]:
                return True

    return False

# Test
root1 = None
x1, y1 = 0, 1

root2 = TreeNode(0)
x2, y2 = 0, 1

root3 = TreeNode(0)
root3.left = TreeNode(1)
x3, y3 = 0, 1

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(2)
x4, y4 = 1, 2

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(3)
root5.right = TreeNode(2)
root5.right.left = TreeNode(4)
x5, y5 = 1, 2

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(3)
root6.right = TreeNode(2)
root6.right.right = TreeNode(4)
x6, y6 = 3, 4

print(fun_69(root1, x1, y1))
print(fun_69(root2, x2, y2))
print(fun_69(root3, x3, y3))
print(fun_69(root4, x4, y4))
print(fun_69(root5, x5, y5))
print(fun_69(root6, x6, y6))

"""<a id='6.10'></a>

## Exercise ($\star\star\star$)
- Problem:
    - find the bottom-left node in a binary tree
    - see examples in the test cases
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(n)$ space
- Skills: 
    - BFS
    - using queue to design a solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_6.10)
"""

# Implementation
def fun_610(root):
    """
    Find the bottom-left node in a binary tree
    
    Parameters
    ----------
    root : the root of a tree
    
    Returns
    ----------
    The value of the bottom-left node in a binary tree
    """

    # Implement me
    # Corner case
    if root == None:
        return root
    
    left_most = root.val
    
    # Initialize the queue
    queue = deque([root])
    
    while len(queue) > 0:
        # Get the length of the queue
        n = len(queue)
        for i in range(n):
            # Remove the first node in the queue
            node = queue.popleft()

            # Update left_most using the value of the left-most node on each level
            if i == 0:
                left_most = node.val

            if node.left != None:
                # Add the value of the left child to the end of the queue
                queue.append(node.left)
            if node.right != None:
                # Add the value of the right child to the end of the queue
                queue.append(node.right)

    return left_most

# Test
root1 = None

root2 = TreeNode(0)

root3 = TreeNode(0)
root3.left = TreeNode(1)

root4 = TreeNode(0)
root4.left = TreeNode(1)
root4.right = TreeNode(2)

root5 = TreeNode(0)
root5.left = TreeNode(1)
root5.left.left = TreeNode(3)
root5.right = TreeNode(2)
root5.right.left = TreeNode(4)

root6 = TreeNode(0)
root6.left = TreeNode(1)
root6.left.left = TreeNode(3)
root6.right = TreeNode(2)
root6.right.right = TreeNode(4)

print(fun_610(root1))
print(fun_610(root2))
print(fun_610(root3))
print(fun_610(root4))
print(fun_610(root5))
print(fun_610(root6))

"""# Appendix

<a id='hints_5.1'></a>

## Hints for [exercise 5.1](#5.1):
- if the root is None (i.e., empty tree), the height is -1
- otherwise, the height is the max of the height of the left and right subtree, plus 1 (the root)

<a id='hints_5.2'></a>

## Hints for [exercise 5.2](#5.2):
- if the two roots are both None, return True
- if only one of the roots is None, return False
- if all of the following three conditions are met, return True
- otherwise, return False
    - if the two roots have the same value
    - if the left subtrees are the same
    - if the right subtrees are the same

<a id='hints_5.3'></a>

## Hints for [exercise 5.3](#5.3):
- if the root is None, return True
- if the left and right subtree are symmetric (determined by a helper function), return True
- otherwise, return False
- particularly, in the helper function
    - if the root of the left and right subtree are both None, the two subtrees are symmetric
    - if only one of the root is None, they are not symmetric
    - if the value of the two roots are not the same, they are not symmetric
    - if the left-left and right-right subtree are symmetric, and the left-right and right-left subtree are symmetric, the two subtrees are symmetric
    - otherwise, they are not symmetric

<a id='hints_5.4'></a>

## Hints for [exercise 5.4](#5.4):
- we compare the list of leaves of each tree (obtained by a helper function)
- in the helper function
    - when the root is None, return []
    - when the root has no children, return [root]
    - otherwise, return the combination of the list of leaves in the left subtree and the list of leaves in the right subtree

<a id='hints_5.5'></a>

## Hints for [exercise 5.5](#5.5):
- we use a global variable, paths, to keep track of the paths
- in the helper function
    - we use a string, path, to keep track of each path
    - when the root is None, return
    - when the root is a leaf
        - add the value of the root to path
        - append path to paths
        - return
    - when the root is not a leaf
        - add the value of the root and the arrow ('->') to path
        - recursively apply the helper function to the left and right subtree

<a id='hints_5.6'></a>

## Hints for [exercise 5.6](#5.6):
- in the helper function, we use two variables, min_ and max_, to keep track of the boundaries (of the value) of a binary tree
- specifically
    - the value of each node, node.val, should satisfy
        - min_ < node.val < max_
    - the value of each node in the left subtree of the node, left_descendant.val, should satisfy
        - min_ < left_descendant.val < node.val
    - the value of each node in the right subtree of the node, right_descendant.val, should satisfy
        - node.val < right_descendant.val < max_

<a id='hints_5.7'></a>

## Hints for [exercise 5.7](#5.7):
- we first create the root based on the middle item of the array
- we then recursively call the function to build the left and right subtree from the left and right subarray

<a id='hints_5.8'></a>

## Hints for [exercise 5.8](#5.8):
- the logic is exactly the same as that for exercise 5.7

<a id='hints_5.9'></a>

## Hints for [exercise 5.9](#5.9):
- we create a dictionary where the key is the student's id, and value is [number of competitions, [friends' id]]
- we use DFS to calculate the sum of the number of competitions the student participated and the number of each of their friends (as long as the corresponding number is not -1)
- we change the number into -1 after visiting each student to avoid infinite loop

<a id='hints_5.10'></a>

## Hints for [exercise 5.10](#5.10):
- we use a variable, count, to keep track of the number of 1s
- we loop over the matrix and for each 1 we:
    - increase count by 1
    - use DFS to remove the connected 1s

<a id='hints_6.1'></a>

## Hints for [exercise 6.1](#6.1):
- we use a variable, height, to keep track of the height of the tree
- we increase height in each round of the level-order traversal

<a id='hints_6.2'></a>

## Hints for [exercise 6.2](#6.2):
- we compare the order-level traversal of the two trees
    - if the two traversals are the same, return True
    - otherwise, return False
- however, we need to tweak the order-level traversal implemented earlier by including None (empty nodes) 
- this allows us to distinguish cases (as shown below) where the traversals are the same but the structures are different
    - 1<-0->None
    - None<-0->1

<a id='hints_6.3'></a>

## Hints for [exercise 6.3](#6.3):
- the logic is almost the same as that for [exercise 6.2](#6.2)
- the difference is
    - here we compare the traversal of each level of the two trees and terminate the algorithm as soon as the traversals are different

<a id='hints_6.4'></a>

## Hints for [exercise 6.4](#6.4):
- the logic is almost the same as that for [exercise 6.3](#6.3)
- the difference is
    - here we compare the node on each level of the two trees and terminate the algorithm as soon as the nodes are different

<a id='hints_6.5'></a>

## Hints for [exercise 6.5](#6.5):
- we use queue to implement BFS
- we use a variable, vals, to keep track of the value of the nodes on each level
- we return False as soon as we find vals is not symmetric
- we return True if all the levels are symmetric

<a id='hints_6.6'></a>

## Hints for [exercise 6.6](#6.6):
- the logic is similar to that for [exercise 6.5](#6.5)
- the difference is
    - on each level instead of adding nodes from left to right (as what we did in [exercise 6.5](#6.5)) to the queue, here we add a pair of nodes that are symmetric in the tree (in terms of their positions)
    - then when we pop the first two nodes in the queue, they are symmetric
    - by doing this, we do not have to use a list to check symmetric nodes on each level

<a id='hints_6.7'></a>

## Hints for [exercise 6.7](#6.7):
- we use queue to implement BFS
- we use a variable, vals, to keep track of the value of the nodes on each level
- after traversing all the nodes, vals will be the value of the leaves on the bottom level

<a id='hints_6.8'></a>

## Hints for [exercise 6.8](#6.8):
- we use queue to implement BFS
- we return True as soon as we find that both of the nodes are child of nodes in the queue (indicating that they are on the same level)
- this can be done by using a dictionary, where the key is the value of the children of nodes in the queue
- we return False after traversing all the nodes

<a id='hints_6.9'></a>

## Hints for [exercise 6.9](#6.9):
- the logic is almost the same as that in [exercise 6.8](#6.8)
- the difference is
    - we also need to check whether the two nodes have the same parent
    - this can be done by making the value of a parent as the value of the dictionary (where the key is the value of the children of the parent)

<a id='hints_6.10'></a>

## Hints for [exercise 6.10](#6.10):
- we use a variable, left_most, to keep track of the value of the left-most node on each level
- after traversing all the nodes, left_most will be the value of the bottom-left node
"""

