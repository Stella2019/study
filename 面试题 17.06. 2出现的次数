编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。

示例:

输入: 25
输出: 9
解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)
 
解题思路
这道题看了很多高人的写法，基本都看不太懂...... 最后看到了书[编程之美]第132页1的数目的解法，这才豁然开朗。
代码是采用python的解法，充分利用切片性质，将当前位拆分为左右两部分，避免绕来绕去的数学整除和求余计算哈。
算法核心思想是分别统计每位（个、十、百、千位等等）出现待查数（比如这道题的2）的次数，然后求和，实现O(n)复杂度

比如我们要统计下面三个数百位上出现2的次数，无非就三种情况，大于2，小于2，等于2

情况1（百位大于2），如：12313
要想百位出现2，由于当前百位是3，那么最终的次数只依赖于更高位
00200-00299 100个数
01200-01299 100个数
...
12200-12299 100个数
所有百位出现2的总个数为从0到12 共13个100，即13*100=1300
即百位3的左侧那部分12加上1共13个百位为1的总数，从0到12共13个数吧，手指头加上脚指头数一数哈，同样，从200到299共100个数哈
结论1：当前位大于2=（当前位的左边部分+1）*10**当前位的右半部分的长度 ，这里就是（12+1）*10**len('13') 那要是左半边为空即开头呢，如345百位是3也大于2，左边为空呢，为空就是0喽，直接就是(0+1)*10**len('45')， 也就是200-299喽

情况2（百位小于2），如12113
要想百位出现2，由于当前位是1，那么最终的次数同样依赖于更高位，只不过会比上面的情况少最后一种
00200-00299 100个数
01200-01299 100个数
...
11200-11299 100个数
那么加起来就是（12）*10**len('13')
结论2：当前位小于2=（当前位的左边部分）*10**当前位的右半部分的长度，这里就是 12*10**len('13')

情况3（百位2等于2），如12213
这种情况稍微复杂那么一丢丢，百位出现2的情况不仅依赖于左半边，还依赖于右半边，不过想通了也就不难了
我们可以将这个数分成两部分：
首先我们取前三位不大于121的所有情况，就是上面的结论2
00200-00299 100个数
01200-01299 100个数
...
11200-11299 100个数，还是12*100个数，（12咋来的？从0到11共12个数哇，100咋来的？从0到99共100个数哇）
其次我们取前三位是122的情况，
12200-12213 这一共是14个数，总的加起来就是百位是2的所有情况了
结论三：当前位等于2=（当前位的左边部分）*10**当前位的右半部分的长度+当前位的右半部分+1 ，这里就是 12*10**len('13')+13+1 13+1就是从0到13共几个数

最后整理成代码逻辑就是：


    sum=0
    依次遍历字符串（正好从高位到低位遍历一遍）：
        case(当前位大于带查找数)：
            sum +=（当前位的左边部分+1）*10**当前位的右半部分的长度
        case(当前位小于带查找数):
            sum +=（当前位的左边部分）*10**当前位的右半部分的长度
        case(当前位等于带查找数)：
            sum +=（当前位的左边部分）*10**当前位的右半部分的长度+当前位的右半部分+1 
（注意我们拆分完后，左右两部分都不含当前位了哈，比如上面的12313这个数，我们的当前百位是3，左半部分是12，右半部分是13）
 
class Solution:
    def numberOf2sInRange(self, n: int) -> int:
        s= str(n) 
        x= 2
        count = 0
        for i in range(len(s)):
            current = int(s[i])
            high = 0 if s[:i]=='' else int(s[:i])
            low =0 if s[i+1:]=='' else int(s[i+1:])
            if current>x:
                count+=(high+1)*(10**len(s[i+1:]))
            elif current<x:
                count += (high) * (10 ** len(s[i + 1:]))
            else:
                count +=(high) * (10 ** len(s[i + 1:]))+low+1
        return count

 
 
解题思路
dp数组11*10，dp[i][j]：第i位为j的2的个数
状态转移方程：
if j≠2：dp[i][j] = dp[i-1][0~9]
else：dp[i][j] = dp[i-1][0~9] + 10**(i-1)
计算个数时从高数位向低数位遍历，并且需要特判当前位为2的情况，只需将结果加上低于当前位的数再加一（加一为0的情况）。
例如：n=5263，从千分位5向个位3遍历，当遇到百分位为2时，结果加上63+1，即200~263共64个百分位为2的数。

 class Solution:
    def numberOf2sInRange(self, n: int) -> int:
        tmp = n
        dp = [[0] * 10 for _ in range(11)]
        for i in range(1, 11):
            ss = 0
            for k in range(10):
                ss += dp[i - 1][k]
            for j in range(10):
                if j == 2:
                    dp[i][j] = ss + 10**(i - 1)
                else:
                    dp[i][j] = ss
        nums = [0]
        while n != 0:
            nums.append(n%10)
            n //= 10
        ans = 0
        for i in range(len(nums)-1,0,-1):
            if nums[i]==2:
                ans += tmp%(10**(i-1))+1
            for j in range(nums[i]):ans += dp[i][j]
        return ans

 
