'''
题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组
中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
'''

'''

概念:在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。 伪代码: 归并排序的改进 
1. 把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，
合并 数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时;则前面 数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i
notes：这一题没法用python做，用python始终是超时的

思路一：很巧妙
在牛客网上运算超时，但是思想很好
例如：
            0 1 2 3
            2 1 3 4     逆序数：1
      copy  1 2 3 4
            1+0+0+0=1
'''

# -*- coding:utf-8 -*-
class Solution:
    def InversePairs(self, data):
        # write code here
        copy = []
        count = 0
        for i in data:
            copy.append(i)
        copy.sort()

        for i in range(len(copy)):
            count += data.index(copy[i])
            data.remove(copy[i])

        return count % 10000000007

'''
思路二：这一题核心还是要用归并排序，归并排序能够有效的减少最坏时间复杂度，但是它有额外的开销，以空间换时间
归并排序，就是把原数据分成两个数组，每次取两个数组中的最小值放入一个新的数组中，直到其中一个数组全部取完

不过还是超时
'''

# -*- coding:utf-8 -*-
class Solution:
    def InversePairs(self, data):
        # write code here
        length = len(data)
        if data == None or length <= 0:
            return 0
        copy = [0] * length
        for i in range(length):
            copy[i] = data[i]

        count = self.InversePairsCore(data, copy, 0, length - 1)
        return count % 10000000007

    def InversePairsCore(self, data, copy, start, end):
        if start == end:
            copy[start] = data[start]
            return 0
        length = (end - start) // 2
        left = self.InversePairsCore(copy, data, start, start + length)
        right = self.InversePairsCore(copy, data, start + length + 1, end)

        # i初始化为前半段最后一个数字的下标
        i = start + length
        # j初始化为后半段最后一个数字的下标
        j = end

        indexCopy = end
        count = 0
        # 对两个数组进行对比取值的过程
        while i >= start and j >= start + length + 1:
            if data[i] > data[j]:
                copy[indexCopy] = data[i]
                indexCopy -= 1
                i -= 1
                count += j - start - length
            else:
                copy[indexCopy] = data[j]
                indexCopy -= 1
                j -= 1

        # 剩下的一个数组未取完的操作
        while i >= start:
            copy[indexCopy] = data[i]
            indexCopy -= 1
            i -= 1
        while j >= start + length + 1:
            copy[indexCopy] = data[j]
            indexCopy -= 1
            j -= 1
        return left + right + count




归并排序,合并有序列表,求逆序对个数

之所以将标题中三者放一起是因为它们有密不可分的关系.
合并有序列表

定义一个空列表 li 用来存放排序后的值;
定义两个 cursor lc 和 rc,分别指向左右列表的首部;
比较 lc 和 rc 指向的值,将较小的值放入 li,同时将指向较小值得游标右移一位;
循环上一步,直到某个游标指向最后;这时左右列表其中一个的全部值已经被加入到 li 中;
将另外一个列表中的剩余值加入到 li 中.

def merge_ordered_list(left, right):
    res = []
    lc = rc = 0
    while lc < len(left) and rc < len(right):
        if left[lc] <= right[rc]:
            res.append(left[lc])
            lc += 1
        else:
            res.append(right[rc])
            rc += 1
    res.extend(left[lc:])
    res.extend(right[rc:])
    return res
由以上代码段可以看出,合并过程中只对左右列表分别进行了一遍历,因此时间复杂度为 O(n)

归并排序

归并排序分为两步:

将数据尽量平均分为左右两部分;
对左右两部分分别进行排序(递归调用);
将左右两部分合并,见上节merge_ordered_list.

'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：778463939
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''
def merge_sort(li):
    if len(li) == 1:
        return li
    # split
    mid_index = len(li) // 2
    left = merge_sort(li[:mid_index])
    right = merge_sort(li[mid_index:])
    # merge
    return merge_ordered_list(left, right)

因为每次都是平均分的,因此将一个长度为 n 的列表分为 n 个长度为 1 的子列表需要lg(n)次操作(可以将拆分过程想象为树的分叉),因此merge_sort需递归调用 n 次;

又因为每次调用的时间复杂度为O(n),故整个过程的时间复杂度为O(nlg(n))

求逆序对个数

如果采用暴力求解,分别求每个元素逆序对,需要两两比较列列表中的元素,时间复杂度为 O(n**2);
结合归并排序可以将时间复杂度降为O(nlg(n));

在第一节合并有序列表第三步中,rc 指向元素right[rc]小于 lc 指向元素left[lc]时, left[lc:]中的每个元素都和right[rc]组成了逆序对,由此可得出逆序对个数,代码如下:

对merge_ordered_list进行稍许修改,记录逆序对个数.

'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：778463939
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''
inversion_count = 0

def merge_ordered_list(left, right):
    global inversion_count
    res = []
    lc = rc = 0
    while lc < len(left) and rc < len(right):
        if left[lc] <= right[rc]:
            res.append(left[lc])
            lc += 1
        else:
            res.append(right[rc])
            rc += 1
            # 统计逆序对个数
            inversion_count += len(left[lc:])
    res.extend(left[lc:])
    res.extend(right[rc:])
    return res
这时调用merge_sort会同时得出li中逆序对个数,时间复杂度为归并排序的复杂度O(nlg(n)).





本题见于算法导论第三版习题2-4

题设：对于一个序列a1,a2,a3…an, 若存在i,j，使得i<j且ai>aj，则称为一个逆序对

输入：一个list对象、

输出：list中逆序对数目

分析：一个朴素的想法是这样的：依次遍历list中每一个元素，对每一个元素，查找其之后的每一个元素并与其比较，出现逆序对则计数+1，时间复杂度为O(n^2)——(n-1)+(n-2)+…+1。

但对于这个算法，实际上有隐含的条件被我们忽略了，例如当我们发现a2<a1时，那么对于和a1比较过的所有元素，与a1形成逆序对的所有元素实际上也与a2形成逆序对（除a2外），实际上时间复杂度可以精简到O(nlogn)。

我们可以换一个思路来考虑这个问题：对于一个a1<a2<a3...<an的有序序列，逆序对是为0的，那么我们实际上是要进行一个排序，当发现一次逆序，计数+1，而排序算法的最优解法为O(nlogn)

代码python实现如下——基于分治思想的归并排序，将有序列表和逆序对计数一同返回的递归解法：

def InversionNum(lst):
    # 改写归并排序,在归并排序中，每当R部分元素先于L部分元素插入原列表时，逆序对数要加L剩余元素数
    if len(lst) == 1:
        return lst,0
    else:
        n = len(lst) // 2
        lst1,count1 = InversionNum(lst[0:n])
        lst2,count2 = InversionNum(lst[n:len(lst)])
        lst,count = Count(lst1,lst2,0)
        return lst,count1+count2+count
 
def Count(lst1, lst2,count): 
    i = 0
    j = 0
    res = []
    while i < len(lst1) and j < len(lst2):
        if lst1[i] <= lst2[j]:
            res.append(lst1[i])
            i += 1
        else:
            res.append(lst2[j])
            count += len(lst1)-i # 当右半部分的元素先于左半部分元素进入有序列表时，逆序对数量增加左半部分剩余的元素数
            j += 1
    res += lst1[i:]
    res += lst2[j:]
    return res,count
 
 
print(InversionNum([11,10,9,8,7,6,5,4,3,2,1]))  # 输出为：[1,2,3,4,5,6,7,8,9,10,11] 55



# -*- coding:utf-8 -*-
class Solution:
    def InversePairs(self, data):
        # write code here
        #用归并排序，归并拼接后用计算排序时元素的index变动了少
        _,s=self.MergeSort(data)
        return s%1000000007
    def MergeSort(self,data):
        n=len(data)
        #递归基
        if n==1:return data, 0
        #分两半来排序
        part1,part2=data[:n//2],data[n//2:]
        sorted_part1,s1=self.MergeSort(part1)
        sorted_part2,s2=self.MergeSort(part2)
        #排序后拼接这两半，拼接后先计数，然后将两个有序序列合并
        s,sorted_temp=0,sorted_part1+sorted_part2
        #用p、q两个指针指向两段，计算q中每个元素离插入点的index差
        p,q,len1,len_all=0,sorted_temp.index(sorted_part2[0]),len(sorted_part1),len(sorted_temp)
        while p<len1 and q<len_all:
            #移动p使p成为插入排序的插入点，计算要移动多少个位置
            while p<len1:
                if sorted_temp[q]<sorted_temp[p]:
                    s+=len1-p
                    break
                p+=1
            q+=1
        #完成排序，并把排序后的内容回溯给上一级做准备
        l=[]
        p,q=0,sorted_temp.index(sorted_part2[0])
        while p<len1 and q<len_all:
            if sorted_temp[p]<sorted_temp[q]:
                l.append(sorted_temp[p])
                p+=1
            else:
                l.append(sorted_temp[q])
                q+=1
        if p==len1:l+=sorted_temp[q:]
        if q==len_all:l+=sorted_part1[p:]
        return l,s+s1+s2
