# -*- coding: utf-8 -*-
"""45天刷题.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xbnDBOniAPA_yDRvtEANVuz3q7DTx-XX
"""



"""bubble sort

1、添加有序标记（flag），当没有元素交换时跳出循环
2、记录有序/无序边界，已有序的元素不需要再被进行比较，因此每轮需比较的数列长度会减少
 ![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhU9JDCUXBibgvVWUtLBiaMKalhDpTPUbkOnu5BicUPicF9wj6WZDdPa8bXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

def bubble_sort(our_list):
  n = len(our_list)
  lastExchangeIndex = 0 #记录最后一次交换元素的位置
  sortBorder = n - 1    #无序数列边界
  for i in range(n):
    flag = True         #有序标记，每轮开始初始值为真
    for j in range(0, sortBorder):
      if our_list[j] > our_list[j + 1]:
        our_list[j], our_list[j + 1] = our_list[j + 1], our_list[j]
        flag = False    #有元素交换，则将标记设置为假
        lastExchangeIndex = j
    sortBorder = lastExchangeIndex
    if flag:
      break
  return our_list

def bubbleSort(alist):
    for passnum in range(len(alist)-1,0,-1):
        for i in range(passnum):
            if alist[i]>alist[i+1]:
                temp = alist[i]
                alist[i] = alist[i+1]
                alist[i+1] = temp

alist = [54,26,93,17,77,31,44,55,20]
bubbleSort(alist)
print(alist)

def shortBubbleSort(alist):
    exchanges = True
    passnum = len(alist)-1
    while passnum > 0 and exchanges:
       exchanges = False
       for i in range(passnum):
           if alist[i]>alist[i+1]:
               exchanges = True
               temp = alist[i]
               alist[i] = alist[i+1]
               alist[i+1] = temp
       passnum = passnum-1

alist=[20,30,40,90,50,60,70,80,100,110]
shortBubbleSort(alist)
print(alist)

# best: o(n) time | O(1) space
# average: O(n^2) time | O(1) space
# Worst:O(n^2) time | O(1) sapce
def bubbleSort(array):
	isSorted = False
	counter = 0
	while not isSorted:
		isSorted = True
		for i in range(len(array) - 1 - counter):
			if array[i] > array[i + 1]:
				swap(i, i + 1, array)
				isSorted = False
		counter += 1
	return array

def swap(i, j, array):
	array[i], array[j] = array[j], array[i]

"""选择排序![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhrwsJAE8ywyP2icU1chQfMNc1qX95PnibmPic2y8KUcDcO6N2S4VVl5X7Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
参考下面的几幅图，红色表示当前找到的未排序序列中的最小值，绿色表示当前被比较的元素：![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhgDRFPQfXicEwQiagAYjWlmmEmUHyiaJu8ialDnjibAIahLz59QzsfSlc2Ag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
又找到一个更小的值2，重新标记它为红色：
![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhPU71QEEBic24hbHp4AqJQYUgucwTia26icgic8CMibXibtv30kobo6LwLJTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
一轮比较后，找到最小值2并标记为黄色，表示就位，继续在未排序序列中寻找最小值：
 ![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhvS4Ficycmno8BN1UZx1ehdKYnvH4mavibk1xP4t9I7dIu80NLsLXKQ6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

#简单选择排序
def selectSort(array):
  n = len(array)
  for i in range(n - 1):
    mark = i
    for j in range(i + 1, n):
      if array[j] < array[mark]:           #如果有比当前array[mark]还小的值，则更新mark值，让新的最小值与后续元素继续比较
        mark = j
    if mark != i:
      array[i], array[mark] = array[mark], array[i]  #如果mark值在内循环中没改变过，不需要交换元素
  return array

"""同时找出最小值与最大值放在数列两侧，两边逐渐逼近，循环次数会减少一些![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhojF3jobLMofrd9efLuM20YXy3NJHGFibqVrtO6ISicldG9EPywvVvcgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

选择排序是种不稳定的排序，虽然代码有优化，但平均时间复杂度始终为 
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕
这种性能差

有一部分球友提交了下面这个版本，此代码中虽然也没有太大问题，但是循环中只要找到小的就交换一次，增加了内存占用。

实际应该为在单次循环时不进行位置交换，而是单次循环后再进行位置交换。
"""

def select_fun(list1):
    n = len(list1)
    for i in range(n-1):  # 开启循环，只需要循环n-1次即可,
        # 假设第i个值为最小值，min_value = list1[i]
        for j in range(i+1, n):  # j 输入i后面的数字
            if list1[j] < list1[i]:  # 如果发现后面存在比最小值档还小的数
                list1[i], list1[j] = list1[j], list1[i]  # 交换顺序
    return list1


if __name__ == '__main__':
    list2 = [3, 5, 6, 1, 2]
    print(select_fun(list2))
    """
    # 输出结果
    [1, 2, 3, 5, 6]
    """

def select_fun(list1):
    n = len(list1)
    count = 0  # 统计更改次数
    for i in range(n-1):  # 开启循环，只需要循环n-1次即可,
        min_index = i
        for j in range(i+1, n):  # j 输入i后面的数字
            if list1[j] < list1[min_index]:  # 如果发现后面存在比最小值档还小的数
                min_index = j  # 这里暂时不更改位置，等循环结束后再更改
        if min_index != i:  # 判断当前的最小值是不是i所在位置
            list1[i], list1[min_index] = list1[min_index], list1[i]
            count += 1
    print('交换次数', count)
    return list1


if __name__ == '__main__':
    list2 = [3, 5, 6, 1, 2]
    print(select_fun(list2))
    """
    # 输出结果
    交换次数 4
    [1, 2, 3, 5, 6]
    """

def selectionSort(alist):
   for fillslot in range(len(alist)-1,0,-1):
       positionOfMax=0
       for location in range(1,fillslot+1):
           if alist[location]>alist[positionOfMax]:
               positionOfMax = location

       temp = alist[fillslot]
       alist[fillslot] = alist[positionOfMax]
       alist[positionOfMax] = temp

alist = [54,26,93,17,77,31,44,55,20]
selectionSort(alist)
print(alist)

def selectionSort(array):
	currentIdx = 0
	while currentIdx < len(array) - 1:
		smallestIdx = currentIdx
		for i in range(currentIdx + 1, len(array)):
			if array[smallestIdx] > array[i]:
				smallestIdx = i
		swap(currentIdx, smallestIdx, array)
		currentIdx += 1
	return array

def swap(i, j, array):
	array[i], array[j] = array[j], array[i]

""" ![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhCfZ5P7aIPW8iaiaXp9vRUTf3LviabWYwg16WFXYfw3WeCsYI0854pWQZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
 以上这个 hailstone 函数满足有穷性吗？意思是对于任意的 n, while 循环都会执行有限次而退出吗？
"""

def hailstone(n):
    length = 1
    while(1 < n):
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
        length += 1
    return length

"""![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhuTMLSoMYNwwb8k2R2Y7VoWibFLsZdOY0RibSzNsA5R4q0wefxAuhs1sA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)"""

def hailstone(n):
    length = 1
    seq = []
    while(1 < n):
        if n % 2 == 0:
            n = n//2
            seq.append(n)
        else:
            n = n * 3 + 1
            seq.append(n)
        length += 1
    return length,seq

print(hailstone(7))
print(hailstone(17))
print(hailstone(103))

"""数组中插入元素"""

def insert(lst, i, e):
    """
    lst：一个数组或向量，Python 就用 list 表达吧
    i：待插入元素的位置
    e：待插入元素
    """

"""1、下标处理：正/负数绝对值大于数组长度则添加在数组末尾和首位，负数绝对值小于数组长度则用index+len(list)来处理

2、None值判断及优化：若插入位置刚好是None值，则直接替换

(PS：元素的插入需要考虑扩容问题，如果原本数组已满，则需要扩容。实际上许多API底层也是用最原始的方式去实现的，只是封装起来了就成了方便调用的API，建议可以的话尝试自己的方式去实现；顺便想下，如果把它封装起来需要优化哪些地方。)
![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhppPcMJ38GeL2libgKJkQaAHUIE3XKhTSOyfxp6SxJXnzzMiaw5aTpO3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

# LeetCode 求中心索引

给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。

我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

示例 1:

输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3 解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。

示例 2:

输入: nums = [1, 2, 3] 输出: -1 解释: 数组中不存在满足此条件的中心索引。

请补充完成下面的代码：
"""

class Solution:
    def pivotIndex(self, nums: List[int]) -> int:

"""![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhicpz2PYHQDNzp7N4pXfafPoDQlyc7PxiaRjXAPnVHa4O4XsHCsWYY8vg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
这种解法是很高效的。

infrared62* 的总结：Java and Python，前缀和的应用，前缀和可以简单看作数列前n项的和，在DP和树路径求和也有应用，同理还有后缀和，前缀积，后缀积。

![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhHfeEsnDTXzaoia9RBALVeKTsncMLxGmN5ku6gZDicBGFiagDibK939l87Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)相比第一种解法，这种求解方法不高效。

因为每迭代一次，都要 sum 求和两次，而 sum 求和本质也是一个循环，所以相当于嵌套 for 循环。

我们需要思考，是否有必要每次都要求和，显然是不必要的。

如果存在中心索引，则一定满足：中心索引左侧和 * 2 + nums[i] == sum(nums)

而 sum(nums) 一定是个定值， 中心索引的左侧求和可放在循环中逐渐累加得到，所以只用一层 for 即可。

# two sum
考察知识点：数组，哈希表(字典)
"""

class Solution:    
      def twoSum(self, nums: List[int], target: int) -> List[int]:

"""思路：结合题目及提示这里使用字典。

用target减去列表中的某个值，并将该值作为key，其下标作为value存放到字典中，接着target依次减去剩下的列表项中的值并判断结果是否存在于字典，如果存在即表示列表中有两个值相加等于target，此时即可直接返回答案。并且字典存储可以起到去重的作用![替代文字](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN25J2oVx98hCSsPxMEqrQsfhvAeAUwiazibRfz8SDk25Vj1ia9ibS1UHmpXGticPWbExPwuHoBjx2e57vZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)输入：待寻找的列表 nums, 两数之和 target

输出：有且仅有满足要求的一对整数的下标

假定：一定存在，且仅有一个答案

题目分析：两个数之和等于 target, 首先标记所有遍历过的数，如果 target 减去当前被遍历到的值 e 后，即 target-e 被标记过，则找到答案。

判断值是否在某个容器中，做到 O(1) 时间复杂度的便是最常用的散列表，对应 Python 中的字典。就本题而言，键为标记元素值，字典值为数组下标，所以更加确定使用字典这个数据结构。
"""

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i,e in enumerate(nums):
            if target -e in d:
                return [i,d.get(target-e)]
            d[e] = i

#o(n) o(n)
def twoNumberSum(array, targetSum):
    nums = {}
	for num in array:
		potentialMatch = targetSum - num
		if potentialMatch in nums:
			return [potentialMatch, num]
	    else:
			nums[num] = True
	return []

# o(nlogn) o(1)
def twoNumberSum(array, targetSum):
    array.sort()
	left = 0
	right = len(array) - 1
	while left < right:
		currentSum = array[left] + array[right]
		if currentSum == targetSum:
			return [array[left], array[right]]
		elif currentSum < targetSum:
			left += 1
		elif currentSum > targetSum:
				right -= 1
	return []

"""避免哈希冲突：

1.拉链法：通过哈希函数，我们可以将键转换为数组的索引(0～M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。

2.线性探测法：基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位解决碰撞冲突。当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：1）命中，该位置的键和被查找的键相同；2）未命中，键为空；3）继续查找，该位置和键被查找的键不同。

Day13 遍历获得链表的第i个节点，至此相信大家对链表的基本操作已经掌握。

获得长度为n 头节点为head链表的第i个节点，代码如下：
"""

def getiNode( head, n, i):
        if i < 0 or i > n: # 检查边界条件
            raise IndexError 
        cur = head
        for _ in range(i):
            cur = cur.next
        return cur

"""对于如下链表，值为23的节点为表头，它的指针域取值是下一个节点的指针，依次类推，最后串成一条线：
「列表转化为链表的任务」，代码如下所示：

传入lst转化链表返回cur_Node:
"""

#访问链表第i个节点
class ListNode:
  def _init_(self, x):
    self.val = x
    self.next = None
#单节点类
class SingleLinkedList:
  def _init_(self):
    self.head = ListNode(None)
  def creatLinkedList(self, lst):
    cur_Node = self.head
    tmp = cur_Node
    for data in lst:
      link_list = ListNode(data)
      tmp.next = link_list
      tmp = link_list
    cur_Node = cur_Node.next
    return cur_Node

"""以上代码实现有一个巧妙之处：self.head=ListNode(None)，设置一个空的哨兵表头，并使tmp和cur_Node分别指向这个空表头，for 中依次创建一个节点，tmp完成链表串联任务。

遍历完成后，cur_Node.next 便是真正的链表表头。

# Day 14 作业题：反转单链表

时间复杂度：

 1常见操作：哈希查找，数组取值，常数加减乘除

logn: 二分查找

 n 计算数组中所有元素和，最大，最小

nlogn：归并排序，堆排序，希尔排序，快速排序


²
 ：冒泡，选择排序

 3：三元方程暴力求解

2^n：求解所有子集

n!：全排列问题。比如：给定字母串，每个字母必须使用，且一次组合中只能使用一次，求所有组合方式；另外还要经典的旅行商 TSP 问题

# 二分查找算法

(left+right) //2 ，更好写法：left + (right-left)//2
迭代中，一定注意while判断中等号问题
二分查找的代码还是很容易写出bug
"""

def binary_search(arr,left,right,hkey):
    while left <= right:
        mid = left + (right-left) // 2
  
        if arr[mid] == hkey:
            return mid
        elif arr[mid] > hkey: # 严格大于
            right = mid - 1 
        else: # 此处严格小于
            left = mid + 1  
            
    return -1 # 表示找不到
if __name__ == "__main__":
    sorted_list = [1,2,3,4,5,6,7,8]
    result = binary_search(sorted_list,0,7,4)
    print(result)

def binary_search(arr,left,right,hkey):
    if len(arr) == 0:
        return -1
  
    if left > right:
        return -1
  
    mid = left + (right-left) // 2
 
    if arr[mid] == hkey:
        return mid
    elif arr[mid] < hkey: # 严格小于
        return binary_search(arr,mid+1,right,hkey) # 折半
    else:
        return binary_search(arr,left,mid-1,hkey)

if __name__ == "__main__":
    sorted_list = [1,2,3,4,5,6,7,8]
    result = binary_search(sorted_list,0,7,4)
    print(result)

"""# 合并两个有序数组 left 和 right：
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHEu1djVmAxkbs0zpl3PLKnZ4Ip7w7UgK04l9WSicviav59blqYx0scqcMJDw5QdQRy42rvibFP3a7Eew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

def merge(left, right):
    i = 0
    j = 0
    temp = []
    while i <= len(left) - 1 and j <= len(right) - 1:
        if left[i] <= right[j]:
            temp.append(left[i])
            i += 1
        else:
            temp.append(right[j])
            j += 1
    temp += left[i:] + right[j:]
    return temp

print(merge([1,3,4],[2,3,3]))

"""# 归并排序
（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

归并排序算法的核心正是 Day 19 的合并两个有序数组，补全如下代码：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGnKRGvDXh0Q0g6Jl3wKhGGdxEIqd5eDCd4r1nTgdtj66GW1PctFsLC11A549HrLFjVgqJtJwWopA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

def mergeSort(arr): 
    if len(arr) >1: 
        mid = len(arr)//2 # Finding the mid of the array 
        L = arr[:mid] # Dividing the array elements  
        R = arr[mid:] # into 2 halves 
  
        mergeSort(L) # Sorting the first half 
        mergeSort(R) # Sorting the second half 
  
        i = j = k = 0
          
        # Copy data to temp arrays L[] and R[] 
        while i < len(L) and j < len(R): 
            if L[i] < R[j]: 
                arr[k] = L[i] 
                i+= 1
            else: 
                arr[k] = R[j] 
                j+= 1
            k+= 1
          
        # Checking if any element was left 
        while i < len(L): 
            arr[k] = L[i] 
            i+= 1
            k+= 1
          
        while j < len(R): 
            arr[k] = R[j] 
            j+= 1
            k+= 1

# Code to print the list 
def printList(arr): 
    for i in range(len(arr)):         
        print(arr[i], end =" ") 
    print() 
  
# driver code to test the above code 
if __name__ == '__main__': 
    arr = [12, 11, 13, 5, 6, 7]  
    print ("Given array is", end ="\n")  
    printList(arr) 
    mergeSort(arr) 
    print("Sorted array is: ", end ="\n") 
    printList(arr)

def mergeSort(alist):
    print("Splitting ",alist)
    if len(alist)>1:
        mid = len(alist)//2
        lefthalf = alist[:mid]
        righthalf = alist[mid:]

        mergeSort(lefthalf)
        mergeSort(righthalf)

        i=0
        j=0
        k=0
        while i<len(lefthalf) and j<len(righthalf):
            if lefthalf[i]<righthalf[j]:
                alist[k]=lefthalf[i]
                i=i+1
            else:
                alist[k]=righthalf[j]
                j=j+1
            k=k+1

        while i<len(lefthalf):
            alist[k]=lefthalf[i]
            i=i+1
            k=k+1

        while j<len(righthalf):
            alist[k]=righthalf[j]
            j=j+1
            k=k+1
    print("Merging ",alist)
    
alist = [54,26,93,17,77,31,44,55,20]
mergeSort(alist)
print(alist)

#nlogn nlogn
def mergeSort(array):
	if len(array) == 1:
		return array
	middleIdx = len(array) // 2
	leftHalf = array[:middleIdx]
	rightHalf = array[middleIdx:]
	return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf))

def mergeSortedArrays(leftHalf, rightHalf):
	sortedArray = [None] * (len(leftHalf) + len(rightHalf))
	k = i = j = 0
	while i < len(leftHalf) and j < len(rightHalf):
		if leftHalf[i] <= rightHalf[j]:
			sortedArray[k] = leftHalf[i]
			i += 1
		else:
			sortedArray[k] = rightHalf[j]
			j += 1
		k += 1
	while i < len(leftHalf):
		sortedArray[k] = leftHalf[i]
		i += 1
		k += 1
	while j < len(rightHalf):
		sortedArray[k] = rightHalf[j]
		j += 1
		k += 1
	return sortedArray

#nlogn n
def mergeSort(array):
	if len(array) <= 1:
		return array
	auxiliaryArray = array[:]
	mergeSortHelper(array, 0, len(array) - 1, auxiliaryArray)
	return array
 
	
def mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray):
	if startIdx == endIdx:
		return
	middleIdx = (startIdx + endIdx) // 2
	mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray)
	mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray)
	doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray)
	
def doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray):
	k = startIdx
	i = startIdx
	j = middleIdx + 1
	while i <= middleIdx and j <= endIdx:
		if auxiliaryArray[i] <= auxiliaryArray[j]:
			mainArray[k] = auxiliaryArray[i]
			i += 1
		else:
			mainArray[k] = auxiliaryArray[j]
			j += 1
		k += 1
	while i <= middleIdx:
		mainArray[k] = auxiliaryArray[i]
		i += 1
		k += 1
	while j <= endIdx:
		mainArray[k] = auxiliaryArray[j]
		j += 1
		k += 1

"""# 使用递归以相反的顺序打印字符串"""

def reverse_print(s):
    if len(s) <= 1:
        return s 
    return reverse_print(s[1:]) + s[0]

"""reverse_print('abcdef')
那么递归过程时，函数reverse_print会不断入栈，示意图如下：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOfQGJV1K2ClcayEAARkEAnkk0ghL5XR80WJciaeSjwQevSpfiaKnDE4vfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)此时栈顶为入参 f 的函数，位于示意图的最底部。

因为它满足了递归返回条件len(s) <= 1，所以栈顶函数首先出栈，并返回值 f，下一个即将出栈的为入参ef的函数，其返回值为fe，如下所示：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOfhlywZ97WGWwvdCAibq7ppwe3gGl0SDRuLP7A1g2RcS7LbPTLJWkPVhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)依次出栈：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOfqgG7CicoL4vibWjI4pKDTFGcM1vsVRtcEHQRPnd7WqutINnZu9m0w16Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOfibs4uQOJlf53Il2sMAwZoJJJEH6PkISNhFuolicEIOlhTffX31eMcjeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOf3aa88E3SehvDgJ5E9PKmZeJXWUmRqrNPKa0MKxibzEwIDrq6fmYKk0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)最后一个留在栈的reverse_print，即将返回我们想要的结果：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOfVWav97XSS10eIbmcZ9we3BcjOlpXeQkiaZOSDicKkZPibOo5vBQNHicjRw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)它也出栈后，我们变得到结果 fedcba
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFffzw6EXDpibpicc4BVZtVOfMqLNBG4zwHmFD8mQQhYRRBf7Z14kUQ1wCib9Po8dsPgFW7qn2psia4gQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

# 递归两两交换链表中的节点

给定链表，交换每两个相邻节点并返回其头节点。

例如，对于列表 1-> 2 -> 3 -> 4，我们应当返回新列表 2 -> 1 -> 4 -> 3 的头节点。

请补充下面函数：
class Solution:
    def swapPairs(self, head: ListNode):
        pass # 请补充
        ![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHE2BIgoO4HiaMx2WBu0VH619iaAy3CTtLzViaOQmcwdNWPD3lZIeAJLuEGGt6x8F1SYXWMGyWYcxZk8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if head is None or head.next is None:
            return head
        tmp = head.next
        r = self.swapPairs(tmp.next)
        tmp.next = head
        head.next = r
        return tmp


if __name__ == "__main__":
    # create ListNode from list a
    a = [1, 2, 3, 4, 5]
    head = ListNode(a[0])
    tmp = head
    for i in range(1, len(a)):
        node = ListNode(a[i])
        tmp.next = node
        tmp = tmp.next
    # swap pairs
    snode = Solution().swapPairs(head)
    # check result
    tmp = snode
    while tmp:
        print(tmp.val)
        tmp = tmp.next

"""# 杨辉三角
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
已知杨辉三角第 i-1行，生成第 i 行为：
[1] + 
[yanghui[-1][i-1] + yanghui[-1][i] for i in range(1, numRows-1)] + 
[1]
"""

class Solution():
 def generate(self, numRows):
  if numRows == 0:
   return []
  elif numRows == 1:
   return [[1]]
  else: # 调用自身生成前 numRows - 1 行的杨辉三角
   yanghui = self.generate(numRows - 1) 
      # 根据倒数第二行再生成最后一行：
   last_row = [1] + [yanghui[-1][i-1] + yanghui[-1][i] for i in range(1, numRows-1)] + [1]
   yanghui.append(last_row)
  return yanghui

"""0-1 背包是一个经典的组合优化问题，其中的思想非常重要。今天我们以一个简单的例子，先来体会 0-1 背包问题。
有一个最大承重量为w的背包，第i件物品的价值为a1[i]，第i件物品的重量为a2[i]，将物品装入背包，求解背包内最大的价值总和可以为多少？
例子：
a1 = [100, 70, 50, 10], a2 = [10, 4, 6, 12], w = 12, 背包内的最大价值总和为 120，分别装入重量为4和6的物品，能获得最大价值为 120

使用递归会使代码变得非常简洁，但是递归利用不慎，很容易就会出现：stack overflow 栈溢出的问题，这是因为通常的递归也需要消耗在系统调用栈上产生的隐式额外空间，这算是我们使用递归所付出的代价。

但是有一类递归非常特殊，它不受此空间开销的影响。它就是一种特殊的递归情况：尾递归。

那么，满足哪些条件才算是尾递归呢？下面的两种代码示例，哪个是尾递归，哪个是一般的递归情况呢？
"""

def sum:1(ls):
    if len(ls) == 0:
        return 0
    return ls[0] + sum1(ls[1:])

def sum2(ls):
    def helper(ls, acc):
        if len(ls) == 0:
            return acc
        return helper(ls[1:], ls[0] + acc) 
    return helper(ls, 0)

"""总结 Day30 尾递归作业

递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。

大家注意：最后一行语句和最后一条指令的区别:

下面代码中sum1函数最后一条语句也是sum1函数，但是最后一条指令显然是加法操作。所以它不是尾递归！
下面函数sum2中的子函数helper的最后一条指令也是helper，所以它是尾递归：
总结：非尾递归中，在最后一次递归调用之后有一个额外的计算。

# x 的 n 次幂
求 x 的 n 次幂，一般解法时间复杂度为：O(n)，你能使用递归写出 O(logn) 的解法吗？
代码主要分三块：

1 递归的基情况，这是必须考虑的

2 处理负次幂

3 递归一次，次幂数减半一次。原理：，所以计算x^2n  只需求出x^n

故代码如下：
"""

class Solution:
    def myPow(self, x: float, n: int) -> float:
        # 基情况
        if n == 0:
            return 1.
        # 处理负次幂情况
        if n < 0:
            x,n = 1/x,-n
        # 递归减半    
        t = n//2
        p = self.myPow(x,t)
        return p**2*x if n&1 else p**2

"""使用递归合并两个有序列表"""

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        pass

注意前提：2个链表都是有序的
方法：使用递归
递归使用：要找base case,
问题规模单调递减：每递归一次，其中一个链表长度减去1，所以时间复杂度为 O(m+n)，m,n分别表示链表l1,l2的结点个数。

class singleList():
 def mergeTwoLists(self, l1, l2):
    # base case 
  if not l1:
   return l2
  if not l2:
   return l1
      
  if l1.val <= l2.val:
   l1.next = self.mergeTwoLists(l1.next, l2) # 递归一次 l1.next执行一次 
   return l1
      
  if l2.val < l1.val:
   l2.next = self.mergeTwoLists(l1, l2.next)
   return l2

"""要找递归方程：f(m+n)=f(0).next -> merge(m+n-1)，转化为代码就是分两种情况："""

if l1.val <= l2.val:
     l1.next = self.mergeTwoLists(l1.next, l2) 
     return l1
      
if l2.val < l1.val:
     l2.next = self.mergeTwoLists(l1, l2.next)
     return l2

"""# 寻找插入位置
寻找有序数组元素插入位置
"""

class Solution(object):
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """

"""示例 1:
输入: [1,3,5,6], 5 输出: 2
示例 2:
输入: [1,3,5,6], 2 输出: 1

![替代文字](https://www.dropbox.com/s/lctdahvts6tfotf/Screenshot%202020-07-17%2023.10.01.png?dl=0)
"""

class Solution(object):
    def searchInsert(self, nums, target):
        left,right = 0,len(nums)-1
        while left<=right:
            mid = (left+right)//2
            if target == nums[mid]:
                return mid 
            elif target < nums[mid]:
                right = mid - 1 
            else:
                left = mid + 1 
        
        return left

class Solution(object):
    def searchInsert(self, nums, target):
        left,right = 0,len(nums)-1
        while left<=right:
            mid = (left+right)//2
            if nums[mid] == target:
                # 需要比较后面元素是否有`target`，直到后一个元素不等于target为止
                while mid + 1 < len(nums) and nums[mid+1]==target:
                    mid+=1
                # 向后插入
                return mid + 1
            elif target < nums[mid]:
                right = mid - 1 
            else:
                left = mid + 1 
        
        return left

"""] Day 13：访问链表第 i 个节点: https://articles.zsxq.com/id_bhk6z4pgw2f2.html
[2] Day 12：链表中如何插入节点: https://articles.zsxq.com/id_wb2o0ksbclwj.html
[3] Day11：宝石与石头: https://articles.zsxq.com/id_nzfbs9geu0q8.html
[4] Day10 ：字母异位词分组: https://t.zsxq.com/F6eMfIE

# he并区间
给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]]

解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

补全下面代码：
"""

class Solution(object):
    def merge(self, intervals):

"""说明，这道题看似简单，实际需要考虑周全。比如出现这样的区间：

输入为 []

[[1,4],[2,4]]

边界情况 [[1,3],[3,4]]

复杂情况 [[1,2],[3,4],[5,6],[0,10],[7,12]]

同时要求时间复杂度尽可能低。

2 分析
S1：首先考虑构成本题的基本结构：如何判断两个线段是否有交集：

两个线段有交集的四种情况：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFuO3UVS4evbTBYfgBMTA6c9DumL1P9r4a90fGE6rKutvXfLylnMwBtp5Iv8ueyOKW2AZyMImmfZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)两个线段无交集的情况：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFuO3UVS4evbTBYfgBMTA6cOKgK6H0IjILm3zSjWGcyojo6uzWIUYEluWMV4CFKtejHqhA1qWSdyg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)S2：合并一堆线段

如下一堆线段，图中标号为线段的编号： ![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFuO3UVS4evbTBYfgBMTA6cticVZ7udp6MUDWBnLkB9BibuubicOm7zqE7iaMxoKP26TBfEIiaF88Yjyvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)为了使得操作更加有序，第一感觉按照线段的左端点从小到大排序：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFuO3UVS4evbTBYfgBMTA6cAw5D8BLfjYX03qvMJOytMGKFoChceVvJS2Ph6ZkYAuHt7tMfdjxJnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这样确保第个线段左端点不大于第个线段左端点。

S3：设置数组 dp

设数组dp[i] 表示合并第i 条线段后的解，即此时数组dp内的各条线段都已经不能再合并。

下面就变为：

已知dp[i]，如何合并第i+1条线段，进而推导出 dp[i+1] 。

若数组dp中最后一个元素的左端点不小于第i+1条线段的右端点，则可与之合并，即满足：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFuO3UVS4evbTBYfgBMTA6c35HtNZlERvFGwdfCWNCIYPvWu3VEEuqNsSQ6H7jjbnbhrb4Pe2RHGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)否则无法合并，直接加入到dp中。

转化为代码：

"""

if item[0] <= dp[-1][1]:  
    dp[-1][1] = max(dp[-1][1],item[1]) # 合并第i+1段
 else:
    dp.append(item) # 无法合并，直接加入到dp中

"""dp数组的初始值为排序后的第一条线段。

S4：转化代码
"""

class Solution(object):
    def merge(self, intervals):
        if len(intervals)==0: return intervals
        a = sorted(intervals,key=lambda x: (x[0],x[1]))
        dp = [a[0]]
        for item in a[1:]:
            if item[0] <= dp[-1][1]:  
                dp[-1][1] = max(dp[-1][1],item[1])
            else:
                dp.append(item)
        return dp

"""一般排序时间复杂度为 O(nlogn)，后面 for 循环时间复杂度为 O(n)，所以综合时间复杂度为 O(nlogn)。

本题目先试用排序降低一部分分析难度，后面使用动态规划思想，问题变化为：已知 dp[i] 如何求出 dp[i+1]问题，并且经过排序后是否合并只与dp[-1]有关。

# 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]

输出: [1,3,12,0,0]

说明:

必须在原数组上操作，不能拷贝额外的数组。

假设两个指针slow和fast分别指向连续零区间的第一个0，最后一个0的后一个位置，如下图所示：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGRVsxHSE77HbNjDXWugVUzzXh1ZBS7hU6GyapicWQzibmHTaefYNWyOZ8vIlicL3xX8WvJ4HiaTo0azg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)那么，fast-slow 正是索引从0~fast区间范围内0元素的个数。

fast指向下一个元素：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGRVsxHSE77HbNjDXWugVUz0NNMTSiaeGMt6qPWibxb0ibARjqEKWatiatoibp3BxsrOv8ics4iaJ27R292g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)若打问号元素为0，根据每步操作的目标是非零元素前移，零元素后移。所以迭代到此处时它已经为0元素，所以至少肯定不用前移，那么就保持原地不动。

若打问号的元素取值非0，根据每步操作的目标是非零元素前移，零元素后移。因为slow~fast这块都为0，所以为了目标，非零元素要和第一个0交换，这样不就实现非零元素前移，零元素后移的目标了吗![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGRVsxHSE77HbNjDXWugVUzY5Xgp4kD9p8FD5t2xkIGhAafD4u2RrVjF9vtC3GwXSWTPOfn8kRagg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)交换
"""

class Solution(object):
    def moveZeroes(self, nums):
        fast,slow=0,0 # 分别指向连续零区间的最右侧、最左侧
        while fast<len(nums):
            # if nums[fast]==0 do nothing 
            if nums[fast]!=0:
                # if fast == slow shows zero isn't found yet
                if fast > slow:# zero exists
                    nums[slow], nums[fast] = nums[fast], 0
                slow += 1
            fast += 1

"""S1，设定两个指针初始分别指向第一个元素：
S2，第一个元素等于0，仅fast前进1步：
S3, 下一次迭代时，fast指向元素不为0，则交换：
同时slow和fast同时都前进一步：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGRVsxHSE77HbNjDXWugVUz2gRHib96icSicyKKZtHoaRR8RpLH01JJfF74Xf9qEMmmOGsKYtKdaTgsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
S4，此时元素等于0，此情况重复步骤S2，因此重复上面操作。

依次类推，罗列出中间的各个状态
"""

#O(N)  O(1)
def moveElementToEnd(array, toMove):
  i = 0
	j =len(array) - 1
	while i < j:
		#[2, 1, 3, 2, 4, 2, 2,2] right pointer move until to 4
		while i < j and array[j] == toMove:
			j -= 1
		if array[i] == toMove:
			array[i], array[j] = array[j], array[i]
		i += 1
	return array

"""# 最大连续1的个数
给定一个二进制数组， 计算其中最大连续1的个数。

示例 1:

输入: [1,1,0,1,1,1]

输出: 3

解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.

注意：

输入的数组只包含 0 和1。
输入数组的长度是正整数，且不超过 10,000。

假定：

假定第0~i 个元素，连续1的最大长度为 maxi

迭代到第i个元素时，连续1的长度为 count![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFYp3wFTxFEEG97h5DRB4d30RZbnH776ia2AseeUG81EvtU7QealZsET7ZUQ2ticTvKLweHibeAZgeag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)f(i+1)表示迭代完第i+1个元素时连续1的最大长度，则分两种情况：

若第 i+1 个元素为 0，则 f(i+1) = max(maxi, count)，连续1的最大长度 count 置 0

若第 i+1 个元素为 1，则 f(i+1) = max(maxi, count+1)，连续1的最大长度 count 加 1![替代文字]
"""

class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        maxi,count=0,0
        for num in nums:
            if num==0:
                maxi = max(maxi,count)
                count = 0
            else:
                maxi = max(maxi,count+1)
                count += 1
        return maxi

"""巧妙之处在于下面这个公式 ：
SUM1=SUM1*i + 1
它实现了遇1加1，遇0置0的功能，非常巧妙：
"""

class Solution(object):
    def continueOne(self, nums):
        sum1, res = 0, 0
        for i in nums:
            #遇1加1，遇0置0
            sum1 = sum1*i + i
            if sum1 > res:
                #记录连续1的长度
                res = sum1
                
        return res

"""# 找到重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2] 输出: 2

示例 2:

输入: [3,1,3,4,2] 输出: 3

一定注意以下几点要求：

1 不能更改原数组（假设数组是只读的）。

2 只能使用额外的 O(1) 的空间。

3 时间复杂度小于 O(n2) 。

4 数组中只有一个重复的数字，但它可能不止重复出现一次。

2.1 二分查找
通常来说，二分查找是对值的二分。

就本题，在已知的条件下，却非常适合对索引二分。

因为题目假定元素取值范围：[1,n]，而数组长度为n+1，所以nums[i], i最大为 n，都不会越界。

那么如何利用好这个条件，是本题求解的关键。

我们思考如下问题：

如果所有元素都不重复，那么不大于i的个数一定为i个，考虑如下序列：
[1,4,2,3]
不大于2的个数为2，不大于3的个数为3.

如果出现不大于i的个数大于i，则意味着一定有重复元素，且重复元素值不大于i. 考虑如下序列：
[1,4,2,4,4]
不大于4的元素个数为5个，则表明重复元素一定位于[1,4]区间，而不可能出现在(4,5]区间。

因此，归纳出根据索引的二分条件找到重复元素的方法：

找到中间索引，即 mid = 0 + len(nums)-1
若nums中不大于mid的元素个数小于或等于mid，则表明重复值位于[mid+1,len(nums)-1]若大于mid，则一定位于区间[0,mid-1] 中
兑现为代码如下：
"""

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left,right = 0,len(nums)-1
        while left <= right:
            mid=(left+right)//2
            count = sum(i<=mid for i in nums) # 生成器迭代求和
            if count <= mid:
                left = mid +1 
            else:
                right = mid-1
        return left

"""二分法的代码一定要注意：等号和left,right取值的变化，我看有些星友的代码写成：right=mid，这种肯定是有问题的，因为下一轮迭代mid的值不变，程序进入死循环。

再有，下面的等号是必须要有的，因为个数等于mid，也意味着重复值不可能在[0,mid]里：

if count <= mid:
    left = mid +1

第二种解法：

位运算

大家思考下面的输入序列：[2,3,1,3]，如何使用位运算找出重复值：

其中，1<<num 实现1向左移动num位；| 表示对应位的或运算& 表示对应位的与运算![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHG6IxUYibibEbR1IZibXz4hgRe2UAxCcLxXYxMic4tHDBQc2yYtMx5QONeppQ7EsHaWpt5ic89WicGSPlXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
每次迭代时，flag |= (1<<num) 实现各个数字填充到对应位，通过这种巧妙的编码方法后：1 被编码为 1<<1，2被编码为 1<<2,3被编码为 1<<3，依次类推。

如下[2,1,3]运算完成后 flag 等于如下最后一行：

![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHG6IxUYibibEbR1IZibXz4hgRelkn7yosKeia6t4PrQ00Nl2rz6SQianEM9KN0Gu9PEmVKmicNichjzJKArw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)巧妙的标记着数字2,1,3.

这样当元素3再来时，再与flag后若大于0，就确保它是重复值：

flag & (1<<num) > 0 ?

这样代码如下所示：
"""

class Solution(object):
    def findDuplicate(self, nums):
        flag = 0
        for num in nums:
            if flag & (1<<num)  > 0:
                return num 
            flag |= (1<<num)

"""第三种解法是通过快慢指针，找出环的入口。

# 判断链表是否有环
通过哈希的方法，代码比较好理解：
"""

class Solution(object):
    def hasCycle(self, head):
        s = set()
        tmp = head
        while tmp:
            if tmp in s:
                return True
            s.add(tmp)
            tmp = tmp.next 
        return False

"""今天主要分析如何使用快慢指针判断链表是否有环，做到O(1)的空间复杂度，O(n)的时间复杂度，因此比哈希方法要更加节省内存空间。
[链接文字](https://mp.weixin.qq.com/s/yzQuL8yM_KpjI9mIu-RO7w)
"""



"""# 找到有环链表的入口点
[链接文字](https://www.dropbox.com/s/2a0lzcp9ohyn8ap/Screenshot%202020-07-18%2003.44.05.png?dl=0)
理解以上，再写出求相遇点的代码就分为两步：

 S1: 求出y ，即环形入口点到相遇点的距离

 s2：一旦求出y ，令一个指针从头节点开始走(即m )，一个指针从相遇点开始走(即L-y )，行走速度相等，此时两个指针相遇时一定满足：m=(n-1)L+(L-y)


"""

class Solution:
    def detectCycle(self, head):
        if not head or not head.next:
            return None
        slow,fast = head,head
        while True:
            if not fast or not fast.next:
                return None
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        slow = head
        while fast != slow:
            fast = fast.next
            slow = slow.next
        return slow

"""# 判断数组能切分为几份
数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:

输入: arr = [4,3,2,1,0]

输出: 1

解释:

将数组分成2块或者更多块，都无法得到所需的结果。例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。

示例 2:

输入: arr = [1,0,2,3,4]

输出: 4

解释:

我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。

注意:

arr 的长度在 [1, 10] 之间。arr[i]是 [0, 1, ..., arr.length - 1]的一种排列。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted

还是从分割线满足的条件处开始分析，如下图要想分割需满足：p1部分的所有元素都小于p2部分的所有元素，简言之：

p1max < p2min
"""

class Solution(object):
    def maxChunksToSorted(self, arr):
        count =0
        for i in range(1,len(arr)):
            p1 = arr[:i]
            p2 = arr[i:]
            if max(p1) <= min(p2):
                count += 1
        return count+1

"""检查所有可能的插槽，如果满足上面的条件：，则认为可分割。但是，这种解法的时间复杂度实际上为:

注意题中一个条件：

数组arr是[0, 1, ..., arr.length - 1]的一种排列。

在这种特定的数值结构下，如果索引到i时，即索引0~i时最大值为maxi，

往下推导一步，这意味着下面式子一定成立吗？，如果真的满足，我们可省掉内层的O(n)时间复杂度！



答案是一定的，因为0~i时最大值为maxi，意味着区间[i+1,n)的最小值都大于maxi。

用反证法证明它，假设区间[i+1,n)有一个值比maxi小，那么就必然有一个比maxi更大的值位于[0,i]处，一个萝卜一个坑，因为[0,len(arr)-1]的元素有且仅有一个，所以与已有事实0~i区间最大值为maxi相违背，所以区间[i+1,n)的最小值大于maxi结论得证。

基于此，优化上面代码：
 
"""

class Solution(object):
    def maxChunksToSorted(self, arr):
        """
        题目假定：arr 的长度在 [1, 10] 之间。
        """ 
        maxn,count=arr[0],0
        for i,num in enumerate(arr):
            maxn = max(maxn,num) # maxn记录着[0,i]的最大值
            if i==maxn: # 若索引0~i时最大值为maxi，则可分割
                count+=1 
        return count

"""# 找到重复值和错误值
1 一种很具特色的数组
数组的取值范围：
1<=nums[i]<=n
其中，数组nums长度为n

这类数组特点鲜明，能够支持两种索引方法。

一种我们是熟知的线性访问方法：0到len(nums)-1或者逆序：
"""

nums = [4,2,3,1] # 取值严格控制在:[1,len(nums)]
for i in range(len(nums)):
    key = i
    print(nums[key],end=" ") # 4 2 3 1

"""另一种，就是它的特色访问方法，支持通过下面极具特点的方式："""

nums = [4,2,3,1]
for i in range(len(nums)):
    key = nums[i]-1
    print(nums[key],end=" ") # 遍历结果 1 2 3 4

"""访问数组的key等于元素值减去1

以后遇到满足取值满足 1<=nums[i]<=n的这类数组，记住要联想到第二种访问方法，很多技巧都是基于这种访问方式。

题目
集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

示例 1:

输入: nums = [1,2,2,4]

输出: [2,3]

注意:

给定数组的长度范围是 [2, 10000]。给定的数组是无序的。

本题错误数据基于此种索引访问方法，能够精巧的求解，从而得到一个空间复杂度为O(n)的解，这太难能可贵了。

我看有的星友写出的解通过set集合方法，得到重复值，实际上set函数返回一个占用O(n)空间复杂度的对象，它不是更高效节省内存的解法。

下面分析怎么利用以上索引访问方法求解此题，原数组存在一对重复值，其他值都是唯一的。假定nums[i] 是重复值，则键 key 等于 nums[i] - 1 必然只存在一对重复值，其他值都唯一。

nums[key] 被遍历到后，我们乘以-1以此标记被访问到，因为key只有一对重复值，所以当第一次接触到这个key值时，我们标记nums[key]为负，再次接触到这个key值时，唯独nums[key]才能小于0，其他的key都不重复，所以再被标记为负值前都为正值，且以后再也没有机会被遍历到。

结论：满足 nums[key] < 0 时，key就是一对重复键，而key又等于abs(nums[i]) - 1，所以重复值为：abs(nums[i]) + 1.

找到重复值后，也就是我们只解码了一对重复key值的其中一个。

试想如果数组无错误，选用key = nums[i]-1遍历数组时，那么数组中所有元素都会被标记为负值。但是出现一对重复后，就会出现两个相等的key值，从而必然一个元素值无法被标记为负，拿个例子演示下：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGSvByauzNujJicQP7hiaiao6WRoBSON37U5bspiaiaIBWVFJ4Lcu6rSMvIiaoInhgU5YusbgGMakeP6pBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGSvByauzNujJicQP7hiaiao6W6Bsjc5qOZn7XjwURjX3FvicgichhHwen4jlvlqNXrT8ahlL0Ticne6THA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGSvByauzNujJicQP7hiaiao6W7Pw442pbiclQKnUgX0JlavI4PaUN8H8r5nianxic2HIecayvo3gtejp6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGSvByauzNujJicQP7hiaiao6WoGM41xMRicb4iamoRPqNicQea4PVlKSDflspEUJMBxZa0UQYShaTTojpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)再次被标记，但是不再乘以-1
![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHGSvByauzNujJicQP7hiaiao6WaiaCicdnIHNIPtbUbhWAeYibibnRicia3g5pKEedEWR2jTiaqPywcapY4H8CQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到元素5未被标记，根据key值与元素值的映射关系: key = nums[i]-1, val = nums[key]，元素5的key为0，所以nums[i] 等于key+1，即为 1，所以错误被标记的值为1。

再验证下，如果1未被错误标记，则key等于key 等于 1-1，即 nums[0]能被标记为负数，所以验证通过。
"""

class Solution(object):
    def findErrorNums(self, nums):
        r = [0,0]
        for i,num in enumerate(nums):
            key = abs(num) - 1 # 减1防止越界，同时利用寻找重复值的特点来设计键
            val = nums[key] 
            if val < 0: # 只有找到重复值时，条件才会满足
                r[0] = key + 1
            else:       
                nums[key] = -val # 数组取值范围[1,n]，用乘以-1标记被访问过
        
        for i,num in enumerate(nums): # 此时nums中只有一个值大于0，就是那个错值
            if num > 0: 
                r[1] = i + 1
        return r

"""# 判断是否存在重复元素
**## 做到空间复杂度O(1)**
在LeetCode217题上额外加一个条件：数组可能的取值范围：[1,n]，基于此判断是否存在重复元素。
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1:
输入: [1,2,3,1] 输出: true 示例 2:
输入: [1,2,3,4] 输出: false 示例 3:
输入: [1,1,1,3,3,4,3,2,4,2] 输出: true

明白上一篇的键(key=[nums[i]-1]) 这种索引方法，解决今天的题目就会很简单。
标记法
如果nums[key] 小于 0 ，则表明此key重复，而key和nums[i]的关系为key = abs(num[i])-1，进而找到重复元素nums[i]
"""

def findDuplicates(nums):
    for num in nums:
        key = abs(num) - 1
        if nums[key] < 0:
            return True
        else:
            nums[key] *= -1
    return False


print(findDuplicates([1,3,1,1]))

"""时间复杂度为O(n)，空间复杂度为O(1).
判断这种特殊数组是否有重复，还可通过直接求和判断，如果无重复，则[1,n]的和为：n(n+1)/2，若不等于，则必然有重复：
"""

def findDuplicates(nums):
    return (len(nums)*(len(nums)+1)) // 2 != sum(nums)

"""时间复杂度为O(1)，空间复杂度为O(1).

# 列表转化为二叉树
递归基情况
"""

if index >= len(nums) or nums[index] is None:
    return None

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def list_to_binarytree(nums):
    def level(index):
        if index >= len(nums) or nums[index] is None:
            return None
        
        root = TreeNode(nums[index])
        root.left = level(2 * index + 1)
        root.right = level(2 * index + 2)
        return root

    return level(0)

binary_tree = list_to_binarytree([3,9,20,None,None,15,7])

"""# 求二叉树最小深度"""

# 递归基的下面两种情况必须考虑进去：    
        if not root.left:
            return 1 + self.minDepth(root.right)
        if not root.right:
            return 1 + self.minDepth(root.left)

class Solution(object):
    def minDepth(self, root):
        if not root:
            return 0 
        if not root.left and not root.right:
            return 1
            
        # 递归基的下面两种情况必须考虑进去：    
        if not root.left:
            return 1 + self.minDepth(root.right)
        if not root.right:
            return 1 + self.minDepth(root.left)

        return 1 + min(self.minDepth(root.left),self.minDepth(root.right))

"""# Day48：是否为单值二叉树
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。

只有给定的树是单值二叉树时，才返回 true；否则返回 false。
示例 1：

输入：[1,1,1,1,1,null,1]
输出：true

示例 2：

输入：[2,2,2,5,2]
输出：false
分析
检测二叉树是否所有节点取值仅有一个，此题的递归基也比较容易找到，分为以下三种情况：

空树，返回True
只有1个节点，返回True
父节点与左或右子节点取值不等，返回False
如果以上都不满足，表明根节点与其左右子节点都相等，这样求解规模减少1。

剩下的就是递归判断：
isUniverse(root.left) and isUniverse(root.right)

"""

class Solution(object):
    def isUnivalTree(self, root):
        if not root: # 1
            return True

        if not root.left and not root.right: #2
            return True

        if root.left and root.left.val!=root.val: #3
            return False
        if root.right and root.right.val!=root.val:
            return False 

        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)

"""# Day49: 对称二叉树
 
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
判断二叉树是否对称，先看看下面代码是否正确，它实现的什么功能？

首先看递归基，分三种情况：

没有根，就是空树，返回True
没有左右子树，返回True
左右子节点val不相等，返回False
递归方程如下，判断左、右子树都对称
sub(left.left,right.right) and sub(left.right,right.left)
注意不是
self.isSymmetric(root.left) and self.isSymmetric(root.right)![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFA4iczicd1hGuiblc8JPnzcs2kY5nXjxXj3cgRibd1W71UcO6ianKt08baNb3F0icCic1vttz6xmtYcjbQA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

class Solution(object):
    def isSymmetric(self, root):
        if not root:
            return True 
        def sub(left,right):
            # 没有左和右，返回True
            if not left and not right:
                return True
            # 没有左或没有右，返回False
            if not left or not right:
                return False
            return left.val == right.val and sub(left.left,right.right) and sub(left.right,right.left)
        return sub(root.left,root.right)

"""# Day50 连续数组
给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:
输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
示例 2:
输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFgFVViaZGITnZOJgHMpVjVX6RdJEQZypQugs3S8ztOsia8aSDVMMN2BKibyosoJWNXVZPgdzUTCl7KA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
前四个元素序列[1,0]和[0,1]都是最长的满足题意的序列。

这道题，最难想的就是把0元素看为-1，一旦想到这点，瞬间此题就会变得明朗起来。

遇到1，count加1，遇到0，count加-1：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFgFVViaZGITnZOJgHMpVjVXpyIQ9vd80E2v7CZRDcPAtXrXhJcciagD4Mvd4wKq5QNUBP1OPNINWMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)等遍历到箭头所指元素1时，count又变为2，因为index=1时，count已经为2，现在又为2则说明中间经过的所有元素(0和1)恰好能抵消，也就是找到了一个满足题意的序列：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFgFVViaZGITnZOJgHMpVjVX9SxwpEYgI9M9JXscwjc1ZRzLfx0ibOmod6vCR5ENhZ3YKiaj4S1BvmvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)继续遍历求count，等count再次为2时，说明count上次等于2与本次等于2间的所有元素0和1恰好能抵消，并且能和上步的count等于两个2的区间合并求和：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFgFVViaZGITnZOJgHMpVjVXicbr3YAPmn6YPaZdTlHia74HPJHhpCvDbBeVMgibiaCibX6md9c5ibIShdIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)count等于1合并：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFgFVViaZGITnZOJgHMpVjVX1kNxEicSvzibiauqB7Z6nph2gtwtHZEyAnzz8orFwDbN8Aq31iaicSlojDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)count等于1再合并：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFgFVViaZGITnZOJgHMpVjVXhUwje2XSQ2xOvnicjrvnMyfmzbWy8LibEYVyCwK2wibnCSEFcXcGkBD9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
"""

def findMaxLength(nums):
    count,maxlen=0,0
    d = {0:-1}
    for i,num in enumerate(nums):
        if num==0:
            count += -1
        else:
            count += 1
        
        if count in d:
            maxlen = max(maxlen,i-d[count]) # d[count] : 第一次等于count的位置
        else:
            d[count]=i
    return maxlen

"""# Day51：连续最长子串
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
创建一个状态机：

对于非元音字符放置到位置0处，
元音字符'a'放置到位置1处，
元音字符'e'放置到位置2处，
元音字符'i'放置到位置4处，
元音字符'o'放置到位置8处，
元音字符'u'放置到位置16处
元音字符之所以放到1，2，4，8，16，是要为位运算创造条件，二进制表示中这些数字都只有1位为1，其他位置都为0. 很明显，为1的位置是标志位。

以处理leetcode字符串为例：

状态机有如下6个取值，非元音字符放置到0处：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFHgqscnO2iatFX82duyyjzE7Ut08jsMvkJs9W8Q3QibYlbdALPOMVYic7EECc6ia0jPt3znRVjAfHmQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)处理第二个字符e时，放置到2处：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFHgqscnO2iatFX82duyyjzEICSBD6ZEibhA1RO64icu4GibBPN0YyaIEgh4yk7RxC0YyjZARroYo4M2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)第三个字符又是e，再次放置到2处：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFHgqscnO2iatFX82duyyjzE5XAmmrFp0icKVhrYqGNkscsZxic7fj0qOLwVdnd0jVBiaM0V1ZDMmPavw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
下面又是两个非元音字符，到字符c为止，字符串leetc就是满足题意(单个元音字符出现偶数次)的最大子字符串。

判断元音字符出现偶数次的方法：二进制表示下，且6个值(0,1,2,4,8,16)都只有一个位为1，所以使用异或运算，某个元音字符出现偶数次时，此位最终状态必然为0；奇数次时最终值必然为1.

接下来，处理下一个字符o，但是后面没有字符o，只出现1次，不满足题意：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHFHgqscnO2iatFX82duyyjzEwWPzDzmFPI6Er95a5SL5RveBguxibdIopZOyf8yeibWTg6IrH9vw3jdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)接下来一样方法处理剩余字符，所以整个字符串满足题意的最长子串为：leetc

如果字符串修改为：leetcodoe，满足题意的最长子串：leetcodo.
"""

class Solution(object):
    def findTheLongestSubstring(self,s):
        state, statedict =  0, {0:-1} #设置此初始值决定下面的代码 i-statedict[state] 这样写
        maxlen = 0
        codedict = {'a':1,'e':2,'i':4,'o':8,'u':16}
        for i,c in enumerate(s):
            if c in codedict:
                state ^= codedict[c]
            if state in statedict:
                maxlen = max(maxlen,i-statedict[state])
            else:
                statedict[state] = i # 记忆新的状态值，二进制位下，可能会出现类似"第1位或第3位为1"的32种组合
        return maxlen

"""statedict 设置{0:-1}初始值，也是很有讲究、很巧妙的，决定了下面的代码 i-statedict[state] 这样写

statedict[state] = i 记忆新的状态值，二进制位下，可能会出现类似第1位或第3位为1的32种组合。
今天题目与Day50的思路极为类似，Day50: 连续数组，可以归纳为前缀和问题。

此类问题关键是想办法巧妙的处理各种状态，区分各种状态。记忆某种状态，中间经历某种变换或抵消操作后，出现了状态字典里的某个状态，表明找到满足题意的前缀。

比如，字符串lee，第一个状态是l，第二个是le，第三个状态又是l，因为2个e能抵消。因此，满足题意的最长子串长度为3.

字符串oeo，第一个状态是o，第二个状态oe，第三个状态是e，两个o抵消，因此没有重复状态。因此，满足题意的最长子串长度为0.

# Day52：二叉树坡度
给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

整个树的坡度就是其所有节点的坡度之和。
"""

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def findTilt(self, root):
        """
        :type root: TreeNode
        :rtype: int

"""从二叉树定义出发：

该节点左子树的结点之和和右子树结点之和的差的绝对值，所以比较容易就能找到递推关系式：
tilt(root) = tilt(root.left) + tilt(root.right) + |sum root.left - sum root.left|

而求左、右子树的节点和，很容易由递推关系式：
sum(root) = sum(root.left) + sum(root.right) + root.val

求得。所以综合以上两个递推关系式发现，它们的递推关系式是一样的，并且递归基也十分相似：
|sum root.left - sum root.right|


root.val



"""

class Solution(object):
    def findTilt(self, root):
        self.tilt = 0
        # 求二叉树节点和，再经过一步转化
        def treeSum(root):
            if not root:
                return 0
            leftSum = treeSum(root.left)
            rightSum = treeSum(root.right)
            self.tilt += abs(leftSum-rightSum)
            return leftSum + rightSum + root.val
        treeSum(root)
        return self.tilt

"""# Day53：使用迭代，完成对二叉树的层序遍历 
二叉树层序遍历用队列实现，实现思路就是广度优先搜索步骤：

1.找出当前顶点的所有邻接点。如果有哪个是没访问过的，就把它标为“已访问”，并且将它入队。（尽管该顶点并未作为“当前顶点”被访问过。）

2.如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。

3.如果当前顶点没有未访问的邻接点，且队列里也没有其他顶点，算法完成。
"""

def levelOrder(self, root):
 # 树的广度优先搜索（层次遍历），使用队列或双向队列
      if not root:
          return []

      search_queue = deque()
      search_queue.append(root)
      result = []

      while search_queue:
          visited = []
          # 找出当前顶点的所有邻接点
          for i in range(len(search_queue)):
          # 如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点
              node = search_queue.popleft()
              visited.append(node.val)
              if node.left:
                  search_queue.append(node.left)
              if node.right:
                  search_queue.append(node.right) 
                  
          result.append(visited)
  
      return result

"""# Day54:  判断是否为平衡二叉树
一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。
一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1，每个节点都满足就是平衡二叉树。

根据上方定义，很容易得到下方递推关系式：

f(root) = isRootBalanced 
          且 f(root.left)
          且 f(root.right)
即：根节点左右子树高度差绝对值不超过1，左右子树也满足平衡。

如何求节点高度，前面已经刷过此题，直接给出递推关系式：

h(node) = 1 + max(h(node.left),h(node.right))
即：节点高度等于1加上节点左右子树的较大高度。
"""

class Solution(object):
    def isBalanced(self, root):
        if not root:
            return True
        # 求节点高度，也就是第二个递推关系式
        def getHeight(root):
            if not root:
                return True
            return 1 + max(getHeight(root.left),getHeight(root.right))
        # 第一个递推关系式
        return abs(getHeight(root.left) - getHeight(root.right)) <=1 and self.isBalanced(root.left) and self.isBalanced(root.right)

"""# Day55: 一维数组的动态和

给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。

请返回 nums 的动态和。
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4]
"""

class Solution(object):
    def runningSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        if not nums:
            return []
        # r先申请好n个位置，防止append时发生扩容耗费时间
        r,s = [0]*len(nums), 0
        
        for i,num in enumerate(nums):
            s += num 
            r[i] = s
        return r

"""# Day56: 判断二叉树是否为二叉搜索树
1 题目
首先给出二叉搜索树的定义：

若对于树中任一节点r ，左（右）子树中的节点（若存在）均不大于（不小于）r ，则称之为二叉搜索树（binary search tree），简称为 BST ，简而言之，即处处满足这种顺序性的二叉树为二叉搜索树。

如下所示：![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHHPw5DYCiaclcgBAO6kBrblFUPsrTicJvy0Jtiakxjsj7NloicRbttGaISGqXlj662TN0SLdgXeey7NiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
根节点不小于左子树且不大于右子树
"""

f(root) = 
 root.left.val <= root.val <= root.right.val 
 && f(root.left) 
 && f(root.right)

class TreeNode():
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def isBinarySortedTree(root):
    if not root:
        return Tree 
    return isBST(root)
    
    def isBST(root,lower=float('-inf'),upper=float('inf')):
        # 二叉树的定义
        if root.val <= lower or upper <= root.val:
            return False
        
        res = True
        if root.left:
            res = isBST(root.left,lower,root.val) # 左子树不大于root
        if res and root.right:
            res = isBST(root.left,root.val,upper) # 右子树不小于root
        return res

"""**二叉搜索树的查找**
根据上文定义，根节点和左右子树可能出现重复元素，所以可能会返回多个关键码值，都返回即可。大家注意这点。

儿查搜索树的查找与二分查找极为相似，大家不妨想一想，每比较一次都能将有效区间长度减半。![替代文字](https://mmbiz.qpic.cn/sz_mmbiz_png/I6v2sIX5XHHPw5DYCiaclcgBAO6kBrblFZJiaN4U5lOO3sUNGbRMrp9ibO9wbusDUGB6ZTxOlO69Bw4Zfn3icwSHQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果target小于root.val，则一定位于左侧分支，反之位于右分支；如果等于root.val，则加入到返回列表中，但是还要继续查找，而不是立即返回。
"""

def searchNode(root: TreeNode, target: int)->List[TreeNode]:
    """
    root: 二叉搜索树的根节点
    target: 节点的val值
    返回值：等于val的所有节点
    """
    r = []
    def search(root,target):
        if not root:
            return r
        if target == root.val:
            r.append(target)
            search(root.left,target)
            search(root.right,target)
        elif target < root.val:
            search(root.left,target)
        else:
            search(root.right,target)
    
    search(root,target)

"""# Day58: 二叉搜索树第K大节点
元素投影到x轴上后，就是按照从小到大排序好的顺序，自然的第K大就是nums[-k]
"""

5
      / \
     3   6
    / \
   2   4
  /
 1
  nums = [1 2 3 4 5 6]

示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4

"""二叉树的中序遍历恰好形成上面的序列。

所以本题非常直观的一个思路，中序遍历保存到一个list，遍历完成后l[-k]就是第k大元素。但是这种思路不光多消耗内存，还费时间。

试想，有必要存储吗？有必要全部便利一遍才找出第k大吗？

都是没有必要的！

二叉搜索树中，第1大 到第len(nums-1)/2大 一定位于右子树中， 
"""

class Solution(object):
    
    def kthLargest(self, root, k):
        self.count = k
        self.found = False # 已经找到为True

        def travel(node):
            if not node or self.found:
                return 
            # 遍历右子树
            travel(node.right)
            
            self.count -= 1
            if self.count == 0:
                self.result = node.val 
                self.found = True
                return 
            
            # 如果k > (len(nums)-1)/2，遍历左子树
            if not self.found: # 没有找到再去左子树
                travel(node.left)

        travel(root)

        return self.result

"""# Day 59: 二叉搜索树的最近公共祖先
对于二叉搜索树，已知两个节点，寻找最近祖先节点，根据下面的递推关系式：

若 node.val < min(p.val,q.val)，则p和q的最近祖先节点一定在右子树；

若 max(p.val,q.val) < node.val，则p和q的最近祖先节点一定在左子树；

其他情况 node.val位于p.val和q.val间(可能等于node.val)，则node就是p和q的最近祖先。
"""

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root.val < min(p.val,q.val):
            return self.lowestCommonAncestor(root.right,p,q)
        elif max(p.val,q.val) < root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        else:
            return root

"""# Day60：删除二叉搜索树的某个节点
这道题被leetcode定为中等难度级别，实话讲确实属于这类级别，虽然思路不难，但是要想一次写出准确无误的代码，仍然不是一件简单的事情。如果你第一次做这道题能很快写出来，说明你对递归的理解、指针的掌控都达到了一定水平。

这道题的思路很straitforward，根据BST的性质，具体说来分为如下几种情况：

如果被删除节点关键码key小于当前根节点nodei.val，则问题规模直接降阶到左子树中

关键码key大于当前根节点nodei.val，直接到右子树中查找

key等于当前根节点nodei.val，又分为4种情况：

(1). nodei 无左右子树，摘除nodei节点，等于直接返回 None

(2). nodei 仅有左子树，摘除nodei节点，等于直接返回 nodei.left

(3). nodei 仅有右子树，摘除nodei节点，等于直接返回 nodei.right

(4). nodei 都有左右子树，麻烦一点，方法之一：选择以nodei.right为根节点的树中最左侧节点，然后替换nodei

最后返回 nodei.

你看，上面的思路应该足够清晰，但是兑现为代码绝对又是另一回事。你首先要对递归有深刻的理解，其次像链表、二叉树等这类具备递归的数据结构，操作它们节点引用问题要时刻保持清醒，很容易出错。

解决方案对象的主方法，调用自定义方法self.__delNodei(root,key)，这个方法的构思思路是这样：

第一个参数是BST树中的任意节点，因为BST严格满足递归，所以选取任意一个以节点nodei为根的树，删除里面等于key的节点。因此，这个功能一旦实现后，只需在参数赋值时赋值它为root即可。
"""

class Solution(object):
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        return self.__delNodei(root,key)

"""所以关键是如何写出def __delNodei(self,nodei,key)方法，下面我们一步一步分析。

根据上面的4种情况分析，我们在情况4时会用到找树的最左节点，为此先写出这个方法def __findMinNode(self,nodei)：
"""

# 找到以nodei为根节点树的最小值
    def __findMinNode(self,nodei):
        if not nodei.left:
            return nodei
        while nodei.left:
            nodei = nodei.left
        return nodei

"""这个比较简单，是链表、二叉树等递归结构的常规迭代思路，注意与向量表i=i+1迭代思路的区别。

先写出第一种大情况，比较简单。因为方法self.__delNodei(nodei.left,key)实现删除等于key的节点后返回对nodei.left节点的引用，所以将nodei的left域指向它即可。
"""

# 假定已经查询到nodei节点，删除后返回nodei节点的引用
    def __delNodei(self,nodei,key):
        if not nodei:
            return None

        #若满足下面条件，一定在左子树
        if key < nodei.val:
            nodei.left = self.__delNodei(nodei.left,key) # 删除后返回nodei.left节点的引用

"""再写出第二种大情况，与上类似："""

# 一定在右子树
        elif nodei.val < key:
            nodei.right = self.__delNodei(nodei.right,key)# 删除后返回nodei.right节点的引用

"""再写出第三种大情况，即找到了等于key节点，又分四种小情况：

被删除节点是叶子节点：直接返回None，就是摘除它了：
"""

# nodei.val== key，删除nodei
        else:
            # 情况1：被删除节点是叶子节点
            if not nodei.left and not nodei.right:
                return None  # 置为None

"""第二、三种小情况很相似，跳过被删除节点nodei，直接返回nodei.left 或 node.right 即可："""

# 情况2：被删除节点无右子树
            if not nodei.right:
                return nodei.left # 跳过nodei,返回指向nodei.left，相当于删除了nodei
            # 情况3：被删除节点无左子树
            if not nodei.left:
                return nodei.right

"""最后一种小情况，大家直接看注释吧："""

# 情况4：被删除节点左右子树都不为空
            # 先找到右子树中最左节点，即右子树最小值节点
            minNodei = self.__findMinNode(nodei.right)
            nodei.val = minNodei.val
            # 删除minNodei，同时返回nodei.right的引用，并赋值给nodei.right
            ## 切记：key已经不是__delNodei的参数key，而是我们找到的minNodei的val值
            nodei.right = self.__delNodei(nodei.right,minNodei.val) 
        
        return nodei