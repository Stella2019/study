## 解题思路

### 贪心

尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

证明：当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。


# -*- coding:utf-8 -*-
class Solution:
    def MaxProductAfterCut(self, n):
        # 动态规划
        if n<2:
            return 0
        if n==2:
            return 1
        if n==3:
            return 2
        products=[0]*(n+1)
        products[0]=0
        products[1]=1
        products[2]=2
        products[3]=3

        for i in range(4,n+1):
            max=0
            for j in range(1,i//2+1):
                product=products[j]*products[i-j]
                if product>max:
                    max=product
            products[i]=max
        #print(products)
        return products[n]

    def MaxProductAfterCut2(self, n):
        # 贪婪算法
        if n < 2:
            return 0
        if n==2:
            return 1
        if n==3:
            return 2
        timesOf3 = n//3
        if n - timesOf3*3 == 1:
            timesOf3 -= 1
        
        timesOf2 = (n - timesOf3 * 3)//2
        return (3**timesOf3) * (2**timesOf2)



if __name__=="__main__":
    print(Solution().MaxProductAfterCut(8))
    print(Solution().MaxProductAfterCut(10))
    #print(Solution().NumberOf1(0))
    print(Solution().MaxProductAfterCut2(8))
    print(Solution().MaxProductAfterCut2(10))
