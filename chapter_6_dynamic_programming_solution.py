# -*- coding: utf-8 -*-
"""chapter_6_dynamic_programming_solution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uKrsQ--gVwPRRxfzIQpn9kZFeno8c21R

<h1>Table of Contents<span class="tocSkip"></span></h1>
<div class="toc"><ul class="toc-item"><li><span><a href="#Overview" data-toc-modified-id="Overview-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Overview</a></span></li><li><span><a href="#Learning-Objectives" data-toc-modified-id="Learning-Objectives-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Learning Objectives</a></span></li><li><span><a href="#Dynamic-Programming" data-toc-modified-id="Dynamic-Programming-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Dynamic Programming</a></span><ul class="toc-item"><li><span><a href="#The-Idea" data-toc-modified-id="The-Idea-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>The Idea</a></span></li><li><span><a href="#The-implementation" data-toc-modified-id="The-implementation-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>The implementation</a></span></li></ul></li><li><span><a href="#Exercises" data-toc-modified-id="Exercises-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>Exercises</a></span><ul class="toc-item"><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.2"><span class="toc-item-num">4.2&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-4.3"><span class="toc-item-num">4.3&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.4"><span class="toc-item-num">4.4&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.5"><span class="toc-item-num">4.5&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-4.6"><span class="toc-item-num">4.6&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.7"><span class="toc-item-num">4.7&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.8"><span class="toc-item-num">4.8&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.9"><span class="toc-item-num">4.9&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-4.10"><span class="toc-item-num">4.10&nbsp;&nbsp;</span>Discussion</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.11"><span class="toc-item-num">4.11&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.12"><span class="toc-item-num">4.12&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star$)" data-toc-modified-id="Exercise-($\star\star$)-4.13"><span class="toc-item-num">4.13&nbsp;&nbsp;</span>Exercise ($\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.14"><span class="toc-item-num">4.14&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Exercise-($\star\star\star$)" data-toc-modified-id="Exercise-($\star\star\star$)-4.15"><span class="toc-item-num">4.15&nbsp;&nbsp;</span>Exercise ($\star\star\star$)</a></span></li><li><span><a href="#Discussion" data-toc-modified-id="Discussion-4.16"><span class="toc-item-num">4.16&nbsp;&nbsp;</span>Discussion</a></span></li></ul></li><li><span><a href="#Appendix" data-toc-modified-id="Appendix-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>Appendix</a></span><ul class="toc-item"><li><span><a href="#Hints-for-exercise-4.1:" data-toc-modified-id="Hints-for-exercise-4.1:-5.1"><span class="toc-item-num">5.1&nbsp;&nbsp;</span>Hints for <a href="#4.1">exercise 4.1</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.2:" data-toc-modified-id="Hints-for-exercise-4.2:-5.2"><span class="toc-item-num">5.2&nbsp;&nbsp;</span>Hints for <a href="#4.2">exercise 4.2</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.4:" data-toc-modified-id="Hints-for-exercise-4.4:-5.3"><span class="toc-item-num">5.3&nbsp;&nbsp;</span>Hints for <a href="#4.4">exercise 4.4</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.5:" data-toc-modified-id="Hints-for-exercise-4.5:-5.4"><span class="toc-item-num">5.4&nbsp;&nbsp;</span>Hints for <a href="#4.5">exercise 4.5</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.7:" data-toc-modified-id="Hints-for-exercise-4.7:-5.5"><span class="toc-item-num">5.5&nbsp;&nbsp;</span>Hints for <a href="#4.7">exercise 4.7</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.8:" data-toc-modified-id="Hints-for-exercise-4.8:-5.6"><span class="toc-item-num">5.6&nbsp;&nbsp;</span>Hints for <a href="#4.8">exercise 4.8</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.9:" data-toc-modified-id="Hints-for-exercise-4.9:-5.7"><span class="toc-item-num">5.7&nbsp;&nbsp;</span>Hints for <a href="#4.9">exercise 4.9</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.11:" data-toc-modified-id="Hints-for-exercise-4.11:-5.8"><span class="toc-item-num">5.8&nbsp;&nbsp;</span>Hints for <a href="#4.11">exercise 4.11</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.11:" data-toc-modified-id="Hints-for-exercise-4.11:-5.9"><span class="toc-item-num">5.9&nbsp;&nbsp;</span>Hints for <a href="#4.11">exercise 4.11</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.12:" data-toc-modified-id="Hints-for-exercise-4.12:-5.10"><span class="toc-item-num">5.10&nbsp;&nbsp;</span>Hints for <a href="#4.12">exercise 4.12</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.13:" data-toc-modified-id="Hints-for-exercise-4.13:-5.11"><span class="toc-item-num">5.11&nbsp;&nbsp;</span>Hints for <a href="#4.13">exercise 4.13</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.14:" data-toc-modified-id="Hints-for-exercise-4.14:-5.12"><span class="toc-item-num">5.12&nbsp;&nbsp;</span>Hints for <a href="#4.14">exercise 4.14</a>:</a></span></li><li><span><a href="#Hints-for-exercise-4.15:" data-toc-modified-id="Hints-for-exercise-4.15:-5.13"><span class="toc-item-num">5.13&nbsp;&nbsp;</span>Hints for <a href="#4.15">exercise 4.15</a>:</a></span></li></ul></li></ul></div>

<b>

<p>
<center>
<font size="5">
Lecture Note for Computer Science Foundations (DATS 6450)
</font>
</center>
</p>

<p>
<center>
<font size="4">
Chapter 6: Dynamic Programming (Solution)
</font>
</center>
</p>

<p>
<center>
<font size="3">
Data Science, Columbian College of Arts & Sciences, George Washington University
</font>
</center>
</p>

<p>
<center>
<font size="3">
Author: Yuxiao Huang
</font>
</center>
</p>

</b>

# Overview
- We will discuss Dynamic Programming (DP), which is a powerful algorithm to lower the time complexity of a recursive solution
- Particularly, the discussion of the algorithm can be divided into two parts:
    - theory, where we will describe the idea of the algorithm
    - coding
        - where (most of the time) we will start with some examples and then work on some exercises
        - particularly, the examples and exercises are organized in such a way that, an exercise (most of the time) is a follow-up on some example prior to it
        - **you should analyze the (time and space) complexity of each example and exercise**
- We will use stars to represent the difficulty of the exercises:
    - $\star$ means very easy
    - $\star\star$ means easy
    - $\star\star\star$ means medium
    - $\star\star\star\star$ means difficult
    - $\star\star\star\star\star$ means very difficult

# Learning Objectives
Students should know:
- the idea and implementation of DP
- how to apply DP to design optimal solutions (ones with the lowest complexity)

# Dynamic Programming

## The Idea
It turns out that, the idea of Dynamic Programming (DP) is closely related to divide-and-conquer. That is, instead of solving a big problem directly (which is usually difficult), we first divide the big problem into small ones, and then solve these small problems. We can see this idea from the example below which, as we discussed in Chapter 1, calculates the $n$th number in [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number).
"""

# Reference: the code below is from Chapter 1 of Lecture Note for Computer Science Foundations (DATS 6450) 
def fun_brute_force(n):
    """
    The brute-force (recursive) solution for Fibonacci series.
    The solution has exponential time complexity and linear space complexity.
    
    Parameters
    ----------
    n : a number
    
    Returns
    ----------
    The nth number in Fibonacci series
    """
        
    # Base
    if n <= 1:
        return n
    
    # Recursion
    return fun_brute_force(n - 2) + fun_brute_force(n - 1)

"""In Chapters 1 and 2, we used the recursion tree in fig. 1 to show that, the time / space complexity of the solution above is exponential / linear (can you explain why?). One reason for the exponential time is that, many nodes in the recursion tree will be calculated multiple times. For example, we will calculate node $f(3)$ twice and node $f(2)$ three times.

<img src="../figure/figure_1.pdf" width="600" height="600">

Figure 1. The recursion tree when $n = 5$.

Intuitively, if we can save the result of each node and simply reuse the result rather than recalculate it, we could avoid redundant computation, hence save run time. It turns out that, this is the defining characteristic of DP. Specifically, DP divides the original problem into subproblems, calculates and stores the result of the subproblems, and reuses the results so that the subproblems only need to be calculated once. In simple words, DP is a divide-and-conquer algorithm that allows computation sharing.

While this is the first time we introduce DP, we actually have used DP to design several solutions. Below is the optimal solution for calculating the $n$th number in the Fibonacci series. Can you see it is actually a DP-based solution (i.e., divide-and-conquer + computation sharing)?
"""

# Reference: the code below is from Chapter 1 of Lecture Note for Computer Science Foundations (DATS 6450) 
def fun_dp_constant(n):
    """
    The optimal solution for Fibonacci series.
    The solution has linear time complexity and constant space complexity.
    
    Parameters
    ----------
    n : a number
    
    Returns
    ----------
    The nth number in Fibonacci series
    
    """
    
    # Implement me
    if n <= 1:
        return n
    
    a, b = 0, 1
        
    for i in range(2, n + 1):
        c = a + b
        a = b
        b = c

    return c

"""Let us walk through the solution above and see why it is DP-based. Here we solve the problem (calculating the $n$th number in Fibonacci series) by looping over $i$ from 2 to $n$ and calculate each $i$th number in the series. This coincides the divide-and-conquer part of a DP-based algorithm (dividing a big problem into small ones). Further, after calculating the $i$th number, we store its value (using $b$) and the value of the $i - 1$th number (using $a$), so that they do not have to be calculated again when computing the $i + 1$th number (assigned to $c$). By doing so, we only need to calculate each number in the series only once. That is, the solution above not only allows divide-and-conquer but also computation sharing, hence is DP-based.

## The implementation

Being one of the most difficult kind of algorithm, implementing DP usually is not straightforward. However, there are two tips that could make using DP a bit easier. Unsurprisingly, the tips are related to the defining characteristic of DP discussed earlier, that is, divide-and-conquer and computation sharing. 

To begin with, we need to find the equation that allows us to divide the problem into subproblems. In Fibonacci series, the equation is

$$
f(n) = f(n - 1) + f(n - 2).
$$

As shown in Section 5 (Hints), we will always mention the equation when discussing the logic of a DP-based solution. You will be very close (to solving the problem using DP) once such equation is found.

What is next is figuring out how to share the computation of the subproblems (so that we only need to calculate them once). This is usually done using a bottom-up approach, where we start from the smallest subproblems and gradually move on to bigger problems. Moreover, we store the results of the problems solved along the way. In the optimal solution (of Fibonacci series), we start from the $0$th and $1$st number (the base), then calculate the number from 2 to $n$ (i.e., bottom-up). This is different from the recursive (brute-force) solution, where we start from the $n$th number, then recursively calculate smaller number (i.e., top-down). Further, after calculating the $i$th number (where $2 \leq i \leq n$), we store its value and the value of the $i - 1$th number, so that they can be reused when calculating the $i + 1$th number (which is the sum of $i - 1$th and $i$th number).

# Exercises

<a id='4.1'></a>

## Exercise ($\star\star$)
- Problem:
    - find the maximum profit by buying and selling stock
    - here
        - the stock returns are stored in an array, where the $i$th element is the return on day $i$
        - you can make no more than one transaction
    - see examples in the test cases
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.2](#4.2)
- Complexity:
    - $O(n^2)$ time
    - $O(1)$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.1)
"""

# Implementation
def fun_41(arr):
    """
    Find the maximum profit by buying and selling stock
    You can make no more than one transaction
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The maximum profit : an integer
    """
    
    # Implement me        
    max_profit = 0

    for i in range(len(arr) - 1):
        for j in range(i + 1, len(arr)):            
            max_profit = max(max_profit, arr[j] - arr[i])

    return max_profit

# Test
import numpy as np
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_41(arr), end='\n\n')

"""<a id='4.2'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.1](#4.1)
    - find the maximum profit by buying and selling stock
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - using dp to design an optimal solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.2)
"""

# Implementation
def fun_42(arr):
    """
    Find the maximum profit by buying and selling stock
    You can make no more than one transaction
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The maximum profit : an integer
    """
    
    # Implement me
    # Corner case
    if len(arr) == 0:
        return 0
        
    min_return, max_profit = arr[0], 0

    for i in range(1, len(arr)):
        max_profit = max(max_profit, arr[i] - min_return)
        min_return = min(min_return, arr[i])

    return max_profit

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_41(arr), end='\n\n')

"""## Discussion
The difference (in run time) between fun_41 and fun_42 is shown in fig. 2. Here, fun_42 (DP-based, $O(n)$ time complexity) is much faster than fun_41 (brute-force, $O(n^2)$ complexity).
"""

# Commented out IPython magic to ensure Python compatibility.
import time
# %matplotlib inline
import matplotlib.pyplot as plt

def plot_43(n, funs, sorted_):
    """
    Plot the run time of the functions (with respect to the input size).
    
    Parameters
    ----------
    n : an integer
    funs : a list of functions
    sorted_ : an integer which says:
              -1 : sorted in descending order
              0 : not sorted
              1 : sorted in ascending order
    """
    
    np.random.seed(0)
    
    x = list(range(1, n + 1))
    ys = [[] for _ in range(len(funs))]

    for i in x:
        arr = list(range(1, i + 1))
        if sorted_ == -1:
            arr = sorted(arr, reverse=True)
        elif sorted_ == 0:
            np.random.shuffle(arr)
        for j in range(len(funs)):
            start = time.time()
            funs[j](arr)
            end = time.time()
            ys[j].append(end - start)
    
    for j in range(len(funs)):
        plt.plot(x, ys[j], label=funs[j].__name__)
    plt.xlabel('$n$', fontsize=20)
    plt.ylabel('Run time', fontsize=20)
    plt.xticks([min(x), max(x)], fontsize=20)
    plt.yticks([min([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))]), max([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))])], fontsize=20)
    plt.legend(fontsize=20)
    plt.tight_layout()
    plt.show()

plot_43(10 ** 2, [fun_41, fun_42], 0)
print("Figure 2. The run time of fun_41 and fun_42.")

"""<a id='4.4'></a>

## Exercise ($\star\star$)
- Problem:
    - find the minimum cost to win a game
    - here
        - the game has a sequence of barriers, numbered from 1 to $n$
        - there is a cost for each barrier, particularly for barrier $i$ the cost is arr[i]
        - after paying the cost of a barrier, you can either pass the barrier alone, or pass the barrier and the one behind it
        - you can start either from the first barrier or the second
        - the minimum cost is zero when there are fewer than two barriers
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.5](#4.5)
- Complexity:
    - $O(2^n)$ time
    - $O(n)$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.4)
"""

# Implementation
def fun_44(arr):
    """
    Find the minimum cost to win a game
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The minimum cost : an integer
    """
    
    # Implement me
    return helper(arr, len(arr))

# Implementation
def helper(arr, n):
    """
    Find the minimum cost to win a game
    
    Parameters
    ----------
    arr : a list of integers
    n : the number of barriers we need to pass
    
    Returns
    ----------
    The minimum cost : an integer
    """
    
    # Implement me
    # Base     
    if n < 2:
        return 0

    return min([helper(arr, n - 1) + arr[n - 1], helper(arr, n - 2) + arr[n - 2]])

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_44(arr), end='\n\n')

"""<a id='4.5'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.4](#4.4)
    - find the minimum cost to win a game
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - using dp to design an optimal solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.5)
"""

# Implementation
def fun_45(arr):
    """
    Find the minimum cost to win a game
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The minimum cost : an integer
    """
    
    # Implement me
    # Corner case    
    a, b, c = 0, 0, 0

    for i in range(2, len(arr) + 1):         
        c = min(a + arr[i - 2], b + arr[i - 1])
        a = b
        b = c

    return c

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_45(arr), end='\n\n')

"""## Discussion
The difference (in run time) between fun_44 and fun_45 is shown in fig. 3. Here, fun_45 (DP-based, $O(n)$ time complexity) is much faster than fun_44 (brute-force, $O(2^n)$ complexity).
"""

plot_43(30, [fun_44, fun_45], 0)
print("Figure 3. The run time of fun_44 and fun_45.")

"""<a id='4.7'></a>

## Exercise ($\star\star$)
- Problem:
    - find the number of ways to reach the exit of a maze (represented by a $m \times n$ matrix)
    - suppose there is a mice in a maze 
        - the mice starts from the entrance, located at entry [0, 0]
        - each time the mice can either move to the right or go down
        - the goal (of the mice) is to find the exit, located at entry [m - 1, n - 1]
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.8](#4.8)
- Complexity:
    - $O(2^{max(m, n)})$ time
    - $O(max(m, n))$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.7)
"""

# Implementation
def fun_47(m, n):
    """
    Find the number of ways to reach the exit of a maze (represented by a m * n matrix)
    
    Parameters
    ----------
    m : the number of rows in the matrix
    n : the number of columns in the matrix
    
    Returns
    ----------
    The number of ways : an integer
    """
    
    # Implement me
    # Base
    if m <= 0 or n <= 0:
        return 0
    if m == 1 or n == 1:
        return 1
    
    return fun_47(m - 1, n) + fun_47(m, n - 1)

# Test
np.random.seed(0)

for i in range(10):
    m, n = np.random.randint(low=0, high=6, size=2)
    print('Input  ' + str(i + 1) + ':', 'm = ' + str(m), 'n = ' + str(n))
    print('Output ' + str(i + 1) + ':', fun_47(m, n), end='\n\n')

"""<a id='4.8'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.7](#4.7)
    - find the number of ways to reach the exit of a maze (represented by a $m \times n$ matrix)
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.9](#4.9)
- Complexity:
    - $O(m \times n)$ time
    - $O(m \times n)$ space
- Skills: 
    - using dp to design an improved solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.8)
"""

# Implementation
def fun_48(m, n):
    """
    Find the number of ways to reach the exit of a maze (represented by a m * n matrix)
    
    Parameters
    ----------
    matrix : a matrix of integers
    m : the number of rows in the matrix
    n : the number of columns in the ma
    
    Returns
    ----------
    The number of ways : an integer
    """
    
    # Implement me
    # Base
    if m <= 0 or n <= 0:
        return 0
    if m == 1 or n == 1:
        return 1
    
    # Create a m * b zero matrix
    matrix = [[0 for _ in range(n)] for _ in range(m)] 
    
    # Initialize the first row
    for j in range(n):
        matrix[0][j] = 1
        
    # Initialize the first column
    for i in range(m):
        matrix[i][0] = 1
        
    # Update the matrix
    for i in range(1, m):
        for j in range(1, n):
            matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]
            
    return matrix[m - 1][n - 1]

# Test
np.random.seed(0)

for i in range(10):
    m, n = np.random.randint(low=0, high=6, size=2)
    print('Input  ' + str(i + 1) + ':', 'm = ' + str(m), 'n = ' + str(n))
    print('Output ' + str(i + 1) + ':', fun_48(m, n), end='\n\n')

"""<a id='4.9'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.8](#4.8)
    - find the number of ways to reach the exit of a maze (represented by a $m \times n$ matrix)
    - find the solution with the complexity below
- Complexity:
    - $O(m \times n)$ time
    - $O(max(m, n))$ space
- Skills: 
    - using dp to design an optimal solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.9)
"""

# Implementation
def fun_49(m, n):
    """
    Find the number of ways to reach the exit of a maze (represented by a m * n matrix)
    
    Parameters
    ----------
    matrix : a matrix of integers
    m : the number of rows in the matrix
    n : the number of columns in the ma
    
    Returns
    ----------
    The number of ways : an integer
    """
    
    # Implement me
    # Base
    if m <= 0 or n <= 0:
        return 0
        
    arr = [1] * n

    for i in range(1, m):
        for j in range(1, n):
            arr[j] += arr[j - 1]

    return arr[n - 1]

# Test
np.random.seed(0)

for i in range(10):
    m, n = np.random.randint(low=0, high=6, size=2)
    print('Input  ' + str(i + 1) + ':', 'm = ' + str(m), 'n = ' + str(n))
    print('Output ' + str(i + 1) + ':', fun_49(m, n), end='\n\n')

"""## Discussion
The difference (in run time) between fun_47, fun_48, and fun_49 is shown in fig. 4. Here, fun_48 and fun_49 (DP-based, $O(m \times n)$ time complexity) is much faster than fun_47 (brute-force, $O(2^{max(m, n)})$ complexity).
"""

def plot_410(n, funs):
    """
    Plot the run time of the functions (with respect to the input size).
    
    Parameters
    ----------
    n : an integer
    funs : a list of functions
    """
    
    np.random.seed(0)
    
    x = list(range(1, n + 1))
    ys = [[] for _ in range(len(funs))]

    for i in x:
        for j in range(len(funs)):
            start = time.time()
            funs[j](i, i)
            end = time.time()
            ys[j].append(end - start)
    
    for j in range(len(funs)):
        plt.plot(x, ys[j], label=funs[j].__name__)
    plt.xlabel('$n$', fontsize=20)
    plt.ylabel('Run time', fontsize=20)
    plt.xticks([min(x), max(x)], fontsize=20)
    plt.yticks([min([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))]), max([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))])], fontsize=20)
    plt.legend(fontsize=20)
    plt.tight_layout()
    plt.show()

plot_410(10, [fun_47, fun_48, fun_49])
print("Figure 4. The run time of fun_47, fun_48, and fun_49")

"""<a id='4.11'></a>

## Exercise ($\star\star$)
- Problem:
    - get the maximum number of candies
    - your niece is going to visit the houses in your street on Halloween night
    - given the number of candies each house has, your goal is to help your niece get the maximum number of candies
    - the only constraint here is, your niece cannot visit two houses in a row
    - that is, if she visited house $i$ already, she cannot visit house $i + 1$
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.12](#4.12)
- Complexity:
    - $O(2^n)$ time
    - $O(n)$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.11)
"""

# Implementation
def fun_411(arr):
    """
    Get the maximum number of candies
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The maximum number of candies : an integer
    """
    
    # Implement me
    # Base
    if len(arr) == 0:
        return 0
    if len(arr) <= 2:
        return max(arr)
    
    return max(fun_411(arr[:-2]) + arr[-1], fun_411(arr[:-1]))

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_411(arr), end='\n\n')

"""<a id='4.12'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.11](#4.11)
    - get the maximum number of candies
    - find the solution with the complexity below
- Complexity:
    - $O(n)$ time
    - $O(1)$ space
- Skills: 
    - using dp to design an optimal solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.12)
"""

# Implementation
def fun_412(arr):
    """
    Get the maximum number of candies
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The maximum number of candies : an integer
    """
    
    # Implement me
    # Corner case
    if len(arr) == 0:
        return 0
    if len(arr) <= 2:
        return max(arr)

    a, b = arr[0], max(arr[:2])

    for i in range(2, len(arr)):
        c = max(a + arr[i], b)
        a = b
        b = c

    return c

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_412(arr), end='\n\n')

"""<a id='4.13'></a>

## Exercise ($\star\star$)
- Problem:
    - find the number of [palindromic](https://en.wikipedia.org/wiki/Palindrome) subarray
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.14](#4.14)
- Complexity:
    - $O(n^3)$ time
    - $O(1)$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.13)
"""

# Implementation
def fun_413(arr):
    """
    Find the number of palindromic subarray
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The number of palindromic subarray : an integer
    """
    
    # Implement me
    count = 0
    
    for i in range(len(arr)):
        for j in range(i, len(arr)):
            # Find whether a subarray is palindromic
            count += helper(arr, i, j)
            
    return count

# Implementation
def helper(arr, i, j):
    """
    Find whether a subarray is palindromic
    
    Parameters
    ----------
    arr : a list of integers
    i : the first index of the subarray
    j : the last index of the subarray
    
    Returns
    ----------
    1 : if the subarray is palindromic
    0 : otherwise
    """
    
    # Implement me
    while i < j:
        if arr[i] != arr[j]:
            return 0
        
        i += 1
        j -= 1
        
    return 1

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_413(arr), end='\n\n')

"""<a id='4.14'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.13](#4.13)
    - find the number of [palindromic](https://en.wikipedia.org/wiki/Palindrome) subarray
    - find the solution with the complexity below
    - this exercise will be followed by
        - [exercise 4.15](#4.15)
- Complexity:
    - $O(n^2)$ time
    - $O(n^2)$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.13)
"""

# Implementation
def fun_414(arr):
    """
    Find the number of palindromic subarray
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The number of palindromic subarray : an integer
    """
    
    # Implement me
    count, n = len(arr), len(arr)
    flags = [1] * (n ** 2)

    # Check palindrom for subarray with length 2
    for j in range(n - 1):
        if arr[j] == arr[j + 1]:
            count += 1
        else:
            flags[n + j] = 0

    # Check palindrom for subarray with length larger than 2
    for i in range(3, n + 1):
        for j in range(n - i + 1):
            if flags[(i - 3) * n + j + 1] == 1 and arr[j] == arr[j + i - 1]:
                count += 1
            else:
                flags[(i - 1) * n + j] = 0

    return count

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_414(arr), end='\n\n')

"""<a id='4.15'></a>

## Exercise ($\star\star\star$)
- Problem:
    - follow up on [exercise 4.14](#4.14)
    - find the number of [palindromic](https://en.wikipedia.org/wiki/Palindrome) subarray
    - find the solution with the complexity below
- Complexity:
    - $O(n^2)$ time
    - $O(n)$ space
- Skills: 
    - solving a problem by starting with a brute-force solution
- Logic: we strongly recommend you to try to find the solution yourself before looking at the [hints](#hints_4.15)
"""

# Implementation
def fun_415(arr):
    """
    Find the number of palindromic subarray
    
    Parameters
    ----------
    arr : a list of integers
    
    Returns
    ----------
    The number of palindromic subarray : an integer
    """
    
    # Implement me
    count, n = len(arr), len(arr)
    flags = [1] * (n * 2)

    # Check palindrom for subarray with length 2
    for j in range(n - 1):
        if arr[j] == arr[j + 1]:
            count += 1
        else:
            flags[n + j] = 0

    # Check palindrom for subarray with length larger than 2
    for i in range(3, n + 1):
        for j in range(n - i + 1):
            if flags[(i - 3) % 2 * n + j + 1] == 1 and arr[j] == arr[j + i - 1]:
                count += 1
                flags[(i - 3) % 2 * n + j] = 1                
            else:
                flags[(i - 3) % 2 * n + j] = 0

    return count

# Test
np.random.seed(0)

for i in range(10):
    n = np.random.randint(low=2, high=11)
    arr = np.random.randint(low=2, high=11, size=n)
    print('Input  ' + str(i + 1) + ':', list(arr))
    print('Output ' + str(i + 1) + ':', fun_415(arr), end='\n\n')

"""## Discussion
The difference (in run time) between fun_413, fun_414, and fun_415 is shown in fig. 5. Here, fun_414 and fun_415 (DP-based, $O(n^2)$ time complexity) are faster than fun_413 (brute-force, $O(n^3)$ complexity).
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import time
# %matplotlib inline
import matplotlib.pyplot as plt

def plot_416(n, funs, sorted_):
    """
    Plot the run time of the functions (with respect to the input size).
    
    Parameters
    ----------
    n : an integer
    funs : a list of functions
    sorted_ : an integer which says:
              -1 : sorted in descending order
              0 : not sorted
              1 : sorted in ascending order
    """
    
    np.random.seed(0)
    
    x = list(range(1, n + 1))
    ys = [[] for _ in range(len(funs))]

    for i in x:
        arr = np.random.randint(low=0, high=2, size=i)
        if sorted_ == -1:
            arr = sorted(arr, reverse=True)
        elif sorted_ == 0:
            np.random.shuffle(arr)
        for j in range(len(funs)):
            start = time.time()
            funs[j](arr)
            end = time.time()
            ys[j].append(end - start)
    
    for j in range(len(funs)):
        plt.plot(x, ys[j], label=funs[j].__name__)
    plt.xlabel('$n$', fontsize=20)
    plt.ylabel('Run time', fontsize=20)
    plt.xticks([min(x), max(x)], fontsize=20)
    plt.yticks([min([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))]), max([ys[j][k] for j in range(len(funs)) for k in range(len(ys[j]))])], fontsize=20)
    plt.legend(fontsize=20)
    plt.tight_layout()
    plt.show()

plot_416(10 ** 2, [fun_413, fun_414, fun_415], 0)
print("Figure 5. The run time of fun_413, fun_414, and fun_415")

"""# Appendix

<a id='hints_4.1'></a>

## Hints for [exercise 4.1](#4.1):
- we use a variable, max_profit, to keep track of the maximum profit
- we loop over each $[i, j]$, where $i$ is the day when buying in and $j$ the day when selling out (and $i < j$)
    - for each $[i, j]$, we update max_profit if it is smaller than the current profit, arr[j] - arr[i]

<a id='hints_4.2'></a>

## Hints for [exercise 4.2](#4.2):
- as in [exercise 4.1](#4.1), we use a variable, max_profit, to keep track of the maximum profit
- the difference is
    - here we also use a variable, min_price, to keep track of the minimum price
    - for each $j$ (the day when selling out)
        - if arr[j] - min_price > max_profit, we update max_profit
        - if arr[j] < min_price, we update min_price

<a id='hints_4.4'></a>

## Hints for [exercise 4.4](#4.4):
- let helper(arr, n) be the minimum cost of passing $n$ barriers, then
$$
helper(arr, n) = min([helper(arr, n - 1) + arr[n - 1], helper(arr, n - 2) + arr[n - 2]])
$$
- that is, the minimum cost of passing $n$ barriers is the smaller cost between passing $n - 1$ barriers plus the cost of the $n - 1$th barrier (the last one in the array, since the array begins with index 0), and passing $n - 2$ barriers plus the cost of the $n - 2$th barrier (the second last one in the array)

<a id='hints_4.5'></a>

## Hints for [exercise 4.5](#4.5):
- unlike [exercise 4.4](#4.4) where we used a top-down approach (from $n$ to 2), here we use a bottom-up approach (from 2 to $n$)
- for the $i$th barrier
    - we use two variables, $a$ and $b$, to represent the minimum cost of passing the first $i - 3$ barriers and the first $i - 2$ barriers
    - we also use a variable, $c$, to represent the minimum cost of passing the first $i$ barriers
    - then $c$ can be written as
$$    
c = min(a + arr[i - 2], b + arr[i - 1])
$$

<a id='hints_4.7'></a>

## Hints for [exercise 4.7](#4.7):
- the number of ways to reach entry $[m, n]$, $f(m, n)$, can be written as
$$
f(m, n) = f(m - 1, n) + f(m, n - 1)
$$
- that is, $f(m, n)$ is the sum of the following two numbers:
    - the number of ways to reach entry $[m - 1, n]$
    - the number of ways to reach entry $[m, n - 1]$

<a id='hints_4.8'></a>

## Hints for [exercise 4.8](#4.8):
- unlike [exercise 4.7](#4.7) where we used a top-down approach (from $[m, n]$ to [1, 1]), here we use a bottom-up approach (from [1, 1] to $[m, n]$)
- specifically
    - we use a matrix to keep track of the number of ways, where $matrix[i, j]$ is the number of ways to reach entry $[i, j]$
    - similar to [exercise 4.7](#4.7), $matrix[i, j]$ can be written as  
    $$
    matrix[i, j] = matrix[i - 1, j] + matrix[i, j - 1]
    $$

<a id='hints_4.9'></a>

## Hints for [exercise 4.9](#4.9):
- the logic is almost the same as that in [exercise 4.8](#4.8)
- the difference is
    - unlike [exercise 4.8](#4.8) where we used a matrix to keep track of the number of ways, here we use an array to do so
    - the idea is that, when calculating $matrix[i, j]$ in [exercise 4.8](#4.8), we only need to know row $i - 1$ and column $j - 1$, hence we do not need to keep the other rows and columns
    - specifically, for each $i$, the number of ways to reach entry $[i, j]$, $arr[j]$, can be written as  
$$
arr[j] = arr[j] + arr[j - 1]
$$

<a id='hints_4.11'></a>

## Hints for [exercise 4.11](#4.11):
- the maximum number of candies your niece can get after visiting the $n$th house, $f(n)$, can be written as
$$
f(n) = max\big(f(n - 2) + arr[n], f(n - 1) \big)
$$

- that is, $f(n)$ is the maximum between the following two numbers:
    - the maximum number of candies after visiting the $n - 2$th house plus the candies house $n$ has 
    - the maximum number of candies after visiting the $n - 1$th house

<a id='hints_4.11'></a>

## Hints for [exercise 4.11](#4.11):
- the maximum number of candies your niece can get after visiting the $n$th house, $f(n)$, can be written as
$$
f(n) = max\big(f(n - 2) + arr[n], f(n - 1) \big)
$$

- that is, $f(n)$ is the maximum between the following two numbers:
    - the maximum number of candies after visiting the $n - 2$th house plus the candies house $n$ has 
    - the maximum number of candies after visiting the $n - 1$th house

<a id='hints_4.12'></a>

## Hints for [exercise 4.12](#4.12):
- unlike [exercise 4.11](#4.11) where we used a top-down approach (from $n$ to 2), here we use a bottom-up approach (from 2 to $n$)
- for the $i$th house
    - we use two variables, $a$, $b$, and $c$ to represent $f(i - 2)$, $f(i - 1)$, and $f(i)$
    - then $c$ can be written as
$$   
c = max(a + arr[i], b)
$$

<a id='hints_4.13'></a>

## Hints for [exercise 4.13](#4.13):
- we use a variable, count, to keep track of the number of palindromic subarray 
- we loop over each possible subarray and increase count if the subarray is palindromic

<a id='hints_4.14'></a>

## Hints for [exercise 4.14](#4.14):
- the logic is almost the same as that in [exercise 4.13](#4.13)
- the difference is
    - in [exercise 4.13](#4.13) we pass the whole subarray from $i$ to $j$ to decide whether the subarray is palindromic
    - the time complexity of doing so is $O(n)$
    - here we use a $n \times n$ matrix to keep track of whether subarray with length 1 to $n$ is palindromic
    - when deciding whether subarray starting from $j$ with length $i$ is palindromic, we only need to check whether subarray from $j + 1$ with length $i - 2$ is palindromic, and whether arr[j] == arr[j + i - 1]
    - the time complexity of doing so is $O(1)$

<a id='hints_4.15'></a>

## Hints for [exercise 4.15](#4.15):
- the logic is almost the same as that in [exercise 4.14](#4.14)
- the difference is
    - unlike [exercise 4.14](#4.14) where we use a $n \times n$ matrix to keep track of whether subarray with length 1 to $n$ is palindromic (hence $O(n^2)$ space complexity), here we do so by using a $2 \times n$ matrix (hence $O(n)$ space complexity)
    - as mentioned in the hints for [exercise 4.14](#4.14), when deciding whether subarray starting from $j$ with length $i$ is palindromic, we only need to check whether subarray from $j + 1$ with length $i - 2$ is palindromic (and whether arr[j] == arr[j + i - 1])
    - this means that we only need to keep track of the status of subarray with length $i - 2$ and $i - 1$ such that
        - the information for length $i - 2$ will be used when deciding subarray with length $i$
        - the information for length $i - 1$ will be used when deciding subarray with length $i + 1$
"""

